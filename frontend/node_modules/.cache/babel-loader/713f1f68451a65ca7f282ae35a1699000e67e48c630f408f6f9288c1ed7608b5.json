{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as msalBrowser from \"@azure/msal-browser\";\nimport { defaultLoggerCallback, ensureValidMsalToken, getAuthority, getKnownAuthorities, getMSALLogLevel, handleMsalError, msalToPublic, publicToMsal } from \"../utils.js\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../../errors.js\";\nimport { getLogLevel } from \"@azure/logger\";\nimport { formatSuccess } from \"../../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, resolveTenantId } from \"../../util/tenantIdUtils.js\";\nimport { DefaultTenantId } from \"../../constants.js\";\n// We keep a copy of the redirect hash.\n// Check if self and location object is defined.\nconst isLocationDefined = typeof self !== \"undefined\" && self.location !== undefined;\n/**\n * Generates a MSAL configuration that generally works for browsers\n * @internal\n */\nfunction generateMsalBrowserConfiguration(options) {\n  var _a;\n  const tenantId = options.tenantId || DefaultTenantId;\n  const authority = getAuthority(tenantId, options.authorityHost);\n  return {\n    auth: {\n      clientId: options.clientId,\n      authority,\n      knownAuthorities: getKnownAuthorities(tenantId, authority, options.disableInstanceDiscovery),\n      // If the users picked redirect as their login style,\n      // but they didn't provide a redirectUri,\n      // we can try to use the current page we're in as a default value.\n      redirectUri: options.redirectUri || (isLocationDefined ? self.location.origin : undefined)\n    },\n    cache: {\n      cacheLocation: \"sessionStorage\",\n      storeAuthStateInCookie: true // Set to true to improve the experience on IE11 and Edge.\n    },\n    system: {\n      loggerOptions: {\n        loggerCallback: defaultLoggerCallback(options.logger, \"Browser\"),\n        logLevel: getMSALLogLevel(getLogLevel()),\n        piiLoggingEnabled: (_a = options.loggingOptions) === null || _a === void 0 ? void 0 : _a.enableUnsafeSupportLogging\n      }\n    }\n  };\n}\n// We keep a copy of the redirect hash.\nconst redirectHash = isLocationDefined ? self.location.hash : undefined;\n/**\n * Uses MSAL Browser 2.X for browser authentication,\n * which uses the [Auth Code Flow](https://learn.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n * @internal\n */\nexport function createMsalBrowserClient(options) {\n  var _a;\n  const loginStyle = options.loginStyle;\n  if (!options.clientId) {\n    throw new CredentialUnavailableError(\"A client ID is required in browsers\");\n  }\n  const clientId = options.clientId;\n  const logger = options.logger;\n  const tenantId = resolveTenantId(logger, options.tenantId, options.clientId);\n  const additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds((_a = options === null || options === void 0 ? void 0 : options.tokenCredentialOptions) === null || _a === void 0 ? void 0 : _a.additionallyAllowedTenants);\n  const authorityHost = options.authorityHost;\n  const msalConfig = generateMsalBrowserConfiguration(options);\n  const disableAutomaticAuthentication = options.disableAutomaticAuthentication;\n  const loginHint = options.loginHint;\n  let account;\n  if (options.authenticationRecord) {\n    account = Object.assign(Object.assign({}, options.authenticationRecord), {\n      tenantId\n    });\n  }\n  // This variable should only be used through calling `getApp` function\n  let app;\n  /**\n   * Return the MSAL account if not set yet\n   * @returns MSAL application\n   */\n  async function getApp() {\n    if (!app) {\n      // Prepare the MSAL application\n      app = await msalBrowser.PublicClientApplication.createPublicClientApplication(msalConfig);\n      // setting the account right after the app is created.\n      if (account) {\n        app.setActiveAccount(publicToMsal(account));\n      }\n    }\n    return app;\n  }\n  /**\n   * Loads the account based on the result of the authentication.\n   * If no result was received, tries to load the account from the cache.\n   * @param result - Result object received from MSAL.\n   */\n  async function handleBrowserResult(result) {\n    try {\n      const msalApp = await getApp();\n      if (result && result.account) {\n        logger.info(`MSAL Browser V2 authentication successful.`);\n        msalApp.setActiveAccount(result.account);\n        return msalToPublic(clientId, result.account);\n      }\n    } catch (e) {\n      logger.info(`Failed to acquire token through MSAL. ${e.message}`);\n    }\n    return;\n  }\n  /**\n   * Handles the MSAL authentication result.\n   * If the result has an account, we update the local account reference.\n   * If the token received is invalid, an error will be thrown depending on what's missing.\n   */\n  function handleResult(scopes, result, getTokenOptions) {\n    var _a;\n    if (result === null || result === void 0 ? void 0 : result.account) {\n      account = msalToPublic(clientId, result.account);\n    }\n    ensureValidMsalToken(scopes, result, getTokenOptions);\n    logger.getToken.info(formatSuccess(scopes));\n    return {\n      token: result.accessToken,\n      expiresOnTimestamp: result.expiresOn.getTime(),\n      refreshAfterTimestamp: (_a = result.refreshOn) === null || _a === void 0 ? void 0 : _a.getTime(),\n      tokenType: \"Bearer\"\n    };\n  }\n  /**\n   * Uses MSAL to handle the redirect.\n   */\n  async function handleRedirect() {\n    const msalApp = await getApp();\n    return handleBrowserResult((await msalApp.handleRedirectPromise(redirectHash)) || undefined);\n  }\n  /**\n   * Uses MSAL to retrieve the active account.\n   */\n  async function getActiveAccount() {\n    const msalApp = await getApp();\n    const activeAccount = msalApp.getActiveAccount();\n    if (!activeAccount) {\n      return;\n    }\n    return msalToPublic(clientId, activeAccount);\n  }\n  /**\n   * Uses MSAL to trigger a redirect or a popup login.\n   */\n  async function login(scopes = []) {\n    const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n    const loginRequest = {\n      scopes: arrayScopes,\n      loginHint: loginHint\n    };\n    const msalApp = await getApp();\n    switch (loginStyle) {\n      case \"redirect\":\n        {\n          await app.loginRedirect(loginRequest);\n          return;\n        }\n      case \"popup\":\n        return handleBrowserResult(await msalApp.loginPopup(loginRequest));\n    }\n  }\n  /**\n   * Tries to retrieve the token silently using MSAL.\n   */\n  async function getTokenSilent(scopes, getTokenOptions) {\n    const activeAccount = await getActiveAccount();\n    if (!activeAccount) {\n      throw new AuthenticationRequiredError({\n        scopes,\n        getTokenOptions,\n        message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\"\n      });\n    }\n    const parameters = {\n      authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,\n      correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,\n      claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,\n      account: publicToMsal(activeAccount),\n      forceRefresh: false,\n      scopes\n    };\n    try {\n      logger.info(\"Attempting to acquire token silently\");\n      const msalApp = await getApp();\n      const response = await msalApp.acquireTokenSilent(parameters);\n      return handleResult(scopes, response);\n    } catch (err) {\n      throw handleMsalError(scopes, err, options);\n    }\n  }\n  /**\n   * Attempts to retrieve the token in the browser through interactive methods.\n   */\n  async function getTokenInteractive(scopes, getTokenOptions) {\n    const activeAccount = await getActiveAccount();\n    if (!activeAccount) {\n      throw new AuthenticationRequiredError({\n        scopes,\n        getTokenOptions,\n        message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\"\n      });\n    }\n    const parameters = {\n      authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,\n      correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,\n      claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,\n      account: publicToMsal(activeAccount),\n      loginHint: loginHint,\n      scopes\n    };\n    const msalApp = await getApp();\n    switch (loginStyle) {\n      case \"redirect\":\n        // This will go out of the page.\n        // Once the InteractiveBrowserCredential is initialized again,\n        // we'll load the MSAL account in the constructor.\n        await msalApp.acquireTokenRedirect(parameters);\n        return {\n          token: \"\",\n          expiresOnTimestamp: 0,\n          tokenType: \"Bearer\"\n        };\n      case \"popup\":\n        return handleResult(scopes, await app.acquireTokenPopup(parameters));\n    }\n  }\n  /**\n   * Attempts to get token through the silent flow.\n   * If failed, get token through interactive method with `doGetToken` method.\n   */\n  async function getToken(scopes, getTokenOptions = {}) {\n    const getTokenTenantId = processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds) || tenantId;\n    if (!getTokenOptions.authority) {\n      getTokenOptions.authority = getAuthority(getTokenTenantId, authorityHost);\n    }\n    // We ensure that redirection is handled at this point.\n    await handleRedirect();\n    if (!(await getActiveAccount()) && !disableAutomaticAuthentication) {\n      await login(scopes);\n    }\n    // Attempts to get the token silently; else, falls back to interactive method.\n    try {\n      return await getTokenSilent(scopes, getTokenOptions);\n    } catch (err) {\n      if (err.name !== \"AuthenticationRequiredError\") {\n        throw err;\n      }\n      if (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.disableAutomaticAuthentication) {\n        throw new AuthenticationRequiredError({\n          scopes,\n          getTokenOptions,\n          message: \"Automatic authentication has been disabled. You may call the authenticate() method.\"\n        });\n      }\n      logger.info(`Silent authentication failed, falling back to interactive method ${loginStyle}`);\n      return getTokenInteractive(scopes, getTokenOptions);\n    }\n  }\n  return {\n    getActiveAccount,\n    getToken\n  };\n}","map":{"version":3,"names":["msalBrowser","defaultLoggerCallback","ensureValidMsalToken","getAuthority","getKnownAuthorities","getMSALLogLevel","handleMsalError","msalToPublic","publicToMsal","AuthenticationRequiredError","CredentialUnavailableError","getLogLevel","formatSuccess","processMultiTenantRequest","resolveAdditionallyAllowedTenantIds","resolveTenantId","DefaultTenantId","isLocationDefined","self","location","undefined","generateMsalBrowserConfiguration","options","tenantId","authority","authorityHost","auth","clientId","knownAuthorities","disableInstanceDiscovery","redirectUri","origin","cache","cacheLocation","storeAuthStateInCookie","system","loggerOptions","loggerCallback","logger","logLevel","piiLoggingEnabled","_a","loggingOptions","enableUnsafeSupportLogging","redirectHash","hash","createMsalBrowserClient","loginStyle","additionallyAllowedTenantIds","tokenCredentialOptions","additionallyAllowedTenants","msalConfig","disableAutomaticAuthentication","loginHint","account","authenticationRecord","Object","assign","app","getApp","PublicClientApplication","createPublicClientApplication","setActiveAccount","handleBrowserResult","result","msalApp","info","e","message","handleResult","scopes","getTokenOptions","getToken","token","accessToken","expiresOnTimestamp","expiresOn","getTime","refreshAfterTimestamp","refreshOn","tokenType","handleRedirect","handleRedirectPromise","getActiveAccount","activeAccount","login","arrayScopes","Array","isArray","loginRequest","loginRedirect","loginPopup","getTokenSilent","parameters","correlationId","claims","forceRefresh","response","acquireTokenSilent","err","getTokenInteractive","acquireTokenRedirect","acquireTokenPopup","getTokenTenantId","name"],"sources":["/Users/user/workspace/eventhorizon/node_modules/@azure/identity/src/msal/browserFlows/msalBrowserCommon.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport * as msalBrowser from \"@azure/msal-browser\";\n\nimport type { MsalBrowserFlowOptions } from \"./msalBrowserOptions.js\";\nimport {\n  defaultLoggerCallback,\n  ensureValidMsalToken,\n  getAuthority,\n  getKnownAuthorities,\n  getMSALLogLevel,\n  handleMsalError,\n  msalToPublic,\n  publicToMsal,\n} from \"../utils.js\";\n\nimport type { AccessToken, GetTokenOptions } from \"@azure/core-auth\";\nimport type { AuthenticationRecord, MsalResult } from \"../types.js\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../../errors.js\";\nimport type { CredentialFlowGetTokenOptions } from \"../credentials.js\";\nimport { getLogLevel } from \"@azure/logger\";\nimport { formatSuccess } from \"../../util/logging.js\";\nimport {\n  processMultiTenantRequest,\n  resolveAdditionallyAllowedTenantIds,\n  resolveTenantId,\n} from \"../../util/tenantIdUtils.js\";\nimport { DefaultTenantId } from \"../../constants.js\";\n\n// We keep a copy of the redirect hash.\n// Check if self and location object is defined.\nconst isLocationDefined = typeof self !== \"undefined\" && self.location !== undefined;\n\n/**\n * Generates a MSAL configuration that generally works for browsers\n * @internal\n */\nfunction generateMsalBrowserConfiguration(\n  options: MsalBrowserFlowOptions,\n): msalBrowser.Configuration {\n  const tenantId = options.tenantId || DefaultTenantId;\n  const authority = getAuthority(tenantId, options.authorityHost);\n  return {\n    auth: {\n      clientId: options.clientId!,\n      authority,\n      knownAuthorities: getKnownAuthorities(tenantId, authority, options.disableInstanceDiscovery),\n      // If the users picked redirect as their login style,\n      // but they didn't provide a redirectUri,\n      // we can try to use the current page we're in as a default value.\n      redirectUri: options.redirectUri || (isLocationDefined ? self.location.origin : undefined),\n    },\n    cache: {\n      cacheLocation: \"sessionStorage\",\n      storeAuthStateInCookie: true, // Set to true to improve the experience on IE11 and Edge.\n    },\n    system: {\n      loggerOptions: {\n        loggerCallback: defaultLoggerCallback(options.logger, \"Browser\"),\n        logLevel: getMSALLogLevel(getLogLevel()),\n        piiLoggingEnabled: options.loggingOptions?.enableUnsafeSupportLogging,\n      },\n    },\n  };\n}\n\n/**\n * Methods that are used by InteractiveBrowserCredential\n * @internal\n */\nexport interface MsalBrowserClient {\n  getActiveAccount(): Promise<AuthenticationRecord | undefined>;\n  getToken(scopes: string[], options: CredentialFlowGetTokenOptions): Promise<AccessToken>;\n}\n\n// We keep a copy of the redirect hash.\nconst redirectHash = isLocationDefined ? self.location.hash : undefined;\n\n/**\n * Uses MSAL Browser 2.X for browser authentication,\n * which uses the [Auth Code Flow](https://learn.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n * @internal\n */\nexport function createMsalBrowserClient(options: MsalBrowserFlowOptions): MsalBrowserClient {\n  const loginStyle = options.loginStyle;\n  if (!options.clientId) {\n    throw new CredentialUnavailableError(\"A client ID is required in browsers\");\n  }\n  const clientId = options.clientId;\n  const logger = options.logger;\n  const tenantId = resolveTenantId(logger, options.tenantId, options.clientId);\n  const additionallyAllowedTenantIds: string[] = resolveAdditionallyAllowedTenantIds(\n    options?.tokenCredentialOptions?.additionallyAllowedTenants,\n  );\n  const authorityHost = options.authorityHost;\n  const msalConfig = generateMsalBrowserConfiguration(options);\n  const disableAutomaticAuthentication = options.disableAutomaticAuthentication;\n  const loginHint = options.loginHint;\n\n  let account: AuthenticationRecord | undefined;\n  if (options.authenticationRecord) {\n    account = {\n      ...options.authenticationRecord,\n      tenantId,\n    };\n  }\n\n  // This variable should only be used through calling `getApp` function\n  let app: msalBrowser.IPublicClientApplication;\n  /**\n   * Return the MSAL account if not set yet\n   * @returns MSAL application\n   */\n  async function getApp(): Promise<msalBrowser.IPublicClientApplication> {\n    if (!app) {\n      // Prepare the MSAL application\n      app = await msalBrowser.PublicClientApplication.createPublicClientApplication(msalConfig);\n\n      // setting the account right after the app is created.\n      if (account) {\n        app.setActiveAccount(publicToMsal(account));\n      }\n    }\n\n    return app;\n  }\n\n  /**\n   * Loads the account based on the result of the authentication.\n   * If no result was received, tries to load the account from the cache.\n   * @param result - Result object received from MSAL.\n   */\n  async function handleBrowserResult(\n    result?: msalBrowser.AuthenticationResult,\n  ): Promise<AuthenticationRecord | undefined> {\n    try {\n      const msalApp = await getApp();\n      if (result && result.account) {\n        logger.info(`MSAL Browser V2 authentication successful.`);\n        msalApp.setActiveAccount(result.account);\n        return msalToPublic(clientId, result.account);\n      }\n    } catch (e: any) {\n      logger.info(`Failed to acquire token through MSAL. ${e.message}`);\n    }\n    return;\n  }\n\n  /**\n   * Handles the MSAL authentication result.\n   * If the result has an account, we update the local account reference.\n   * If the token received is invalid, an error will be thrown depending on what's missing.\n   */\n  function handleResult(\n    scopes: string | string[],\n    result?: MsalResult,\n    getTokenOptions?: GetTokenOptions,\n  ): AccessToken {\n    if (result?.account) {\n      account = msalToPublic(clientId, result.account);\n    }\n    ensureValidMsalToken(scopes, result, getTokenOptions);\n    logger.getToken.info(formatSuccess(scopes));\n    return {\n      token: result.accessToken,\n      expiresOnTimestamp: result.expiresOn.getTime(),\n      refreshAfterTimestamp: result.refreshOn?.getTime(),\n      tokenType: \"Bearer\",\n    };\n  }\n\n  /**\n   * Uses MSAL to handle the redirect.\n   */\n  async function handleRedirect(): Promise<AuthenticationRecord | undefined> {\n    const msalApp = await getApp();\n    return handleBrowserResult((await msalApp.handleRedirectPromise(redirectHash)) || undefined);\n  }\n\n  /**\n   * Uses MSAL to retrieve the active account.\n   */\n  async function getActiveAccount(): Promise<AuthenticationRecord | undefined> {\n    const msalApp = await getApp();\n    const activeAccount = msalApp.getActiveAccount();\n    if (!activeAccount) {\n      return;\n    }\n    return msalToPublic(clientId, activeAccount);\n  }\n\n  /**\n   * Uses MSAL to trigger a redirect or a popup login.\n   */\n  async function login(scopes: string | string[] = []): Promise<AuthenticationRecord | undefined> {\n    const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n    const loginRequest: msalBrowser.RedirectRequest = {\n      scopes: arrayScopes,\n      loginHint: loginHint,\n    };\n    const msalApp = await getApp();\n    switch (loginStyle) {\n      case \"redirect\": {\n        await app.loginRedirect(loginRequest);\n        return;\n      }\n      case \"popup\":\n        return handleBrowserResult(await msalApp.loginPopup(loginRequest));\n    }\n  }\n\n  /**\n   * Tries to retrieve the token silently using MSAL.\n   */\n  async function getTokenSilent(\n    scopes: string[],\n    getTokenOptions?: CredentialFlowGetTokenOptions,\n  ): Promise<AccessToken> {\n    const activeAccount = await getActiveAccount();\n    if (!activeAccount) {\n      throw new AuthenticationRequiredError({\n        scopes,\n        getTokenOptions,\n        message:\n          \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n      });\n    }\n\n    const parameters: msalBrowser.SilentRequest = {\n      authority: getTokenOptions?.authority || msalConfig.auth.authority!,\n      correlationId: getTokenOptions?.correlationId,\n      claims: getTokenOptions?.claims,\n      account: publicToMsal(activeAccount),\n      forceRefresh: false,\n      scopes,\n    };\n\n    try {\n      logger.info(\"Attempting to acquire token silently\");\n      const msalApp = await getApp();\n      const response = await msalApp.acquireTokenSilent(parameters);\n      return handleResult(scopes, response);\n    } catch (err: any) {\n      throw handleMsalError(scopes, err, options);\n    }\n  }\n\n  /**\n   * Attempts to retrieve the token in the browser through interactive methods.\n   */\n  async function getTokenInteractive(\n    scopes: string[],\n    getTokenOptions?: CredentialFlowGetTokenOptions,\n  ): Promise<AccessToken> {\n    const activeAccount = await getActiveAccount();\n    if (!activeAccount) {\n      throw new AuthenticationRequiredError({\n        scopes,\n        getTokenOptions,\n        message:\n          \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n      });\n    }\n\n    const parameters: msalBrowser.RedirectRequest = {\n      authority: getTokenOptions?.authority || msalConfig.auth.authority!,\n      correlationId: getTokenOptions?.correlationId,\n      claims: getTokenOptions?.claims,\n      account: publicToMsal(activeAccount),\n      loginHint: loginHint,\n      scopes,\n    };\n    const msalApp = await getApp();\n    switch (loginStyle) {\n      case \"redirect\":\n        // This will go out of the page.\n        // Once the InteractiveBrowserCredential is initialized again,\n        // we'll load the MSAL account in the constructor.\n\n        await msalApp.acquireTokenRedirect(parameters);\n        return { token: \"\", expiresOnTimestamp: 0, tokenType: \"Bearer\" };\n      case \"popup\":\n        return handleResult(scopes, await app.acquireTokenPopup(parameters));\n    }\n  }\n\n  /**\n   * Attempts to get token through the silent flow.\n   * If failed, get token through interactive method with `doGetToken` method.\n   */\n  async function getToken(\n    scopes: string[],\n    getTokenOptions: CredentialFlowGetTokenOptions = {},\n  ): Promise<AccessToken> {\n    const getTokenTenantId =\n      processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds) ||\n      tenantId;\n\n    if (!getTokenOptions.authority) {\n      getTokenOptions.authority = getAuthority(getTokenTenantId, authorityHost);\n    }\n\n    // We ensure that redirection is handled at this point.\n    await handleRedirect();\n\n    if (!(await getActiveAccount()) && !disableAutomaticAuthentication) {\n      await login(scopes);\n    }\n\n    // Attempts to get the token silently; else, falls back to interactive method.\n    try {\n      return await getTokenSilent(scopes, getTokenOptions);\n    } catch (err: any) {\n      if (err.name !== \"AuthenticationRequiredError\") {\n        throw err;\n      }\n      if (getTokenOptions?.disableAutomaticAuthentication) {\n        throw new AuthenticationRequiredError({\n          scopes,\n          getTokenOptions,\n          message:\n            \"Automatic authentication has been disabled. You may call the authenticate() method.\",\n        });\n      }\n      logger.info(`Silent authentication failed, falling back to interactive method ${loginStyle}`);\n      return getTokenInteractive(scopes, getTokenOptions);\n    }\n  }\n  return {\n    getActiveAccount,\n    getToken,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}