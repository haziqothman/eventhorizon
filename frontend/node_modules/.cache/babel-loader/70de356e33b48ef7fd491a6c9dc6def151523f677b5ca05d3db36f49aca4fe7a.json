{"ast":null,"code":"/*! @azure/msal-browser v4.15.0 2025-07-08 */\n'use strict';\n\nimport { CacheManager, createCacheError, CacheErrorCodes, invokeAsync, PerformanceEvents, AccountEntity, CacheHelpers, Constants, PersistentCacheKeys, TimeUtils, StringUtils, CacheError, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { StaticCacheKeys, BrowserCacheLocation, InMemoryCacheKeys, TemporaryCacheKeys, INTERACTION_TYPE } from '../utils/BrowserConstants.mjs';\nimport { LocalStorage } from './LocalStorage.mjs';\nimport { SessionStorage } from './SessionStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { CookieStorage } from './CookieStorage.mjs';\nimport { getAccountKeys, getTokenKeys } from './CacheHelpers.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { clearHash } from '../utils/BrowserUtils.mjs';\nimport { version } from '../packageMetadata.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\nclass BrowserCacheManager extends CacheManager {\n  constructor(clientId, cacheConfig, cryptoImpl, logger, performanceClient, eventHandler, staticAuthorityOptions) {\n    super(clientId, cryptoImpl, logger, performanceClient, staticAuthorityOptions);\n    this.cacheConfig = cacheConfig;\n    this.logger = logger;\n    this.internalStorage = new MemoryStorage();\n    this.browserStorage = getStorageImplementation(clientId, cacheConfig.cacheLocation, logger, performanceClient);\n    this.temporaryCacheStorage = getStorageImplementation(clientId, cacheConfig.temporaryCacheLocation, logger, performanceClient);\n    this.cookieStorage = new CookieStorage();\n    this.eventHandler = eventHandler;\n  }\n  async initialize(correlationId) {\n    await this.browserStorage.initialize(correlationId);\n    this.trackVersionChanges(correlationId);\n  }\n  /**\r\n   * Tracks upgrades and downgrades for telemetry and debugging purposes\r\n   */\n  trackVersionChanges(correlationId) {\n    const previousVersion = this.browserStorage.getItem(StaticCacheKeys.VERSION);\n    if (previousVersion) {\n      this.logger.info(`MSAL.js was last initialized by version: ${previousVersion}`);\n      this.performanceClient.addFields({\n        previousLibraryVersion: previousVersion\n      }, correlationId);\n    }\n    if (previousVersion !== version) {\n      this.setItem(StaticCacheKeys.VERSION, version, correlationId);\n    }\n  }\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n  validateAndParseJson(jsonValue) {\n    try {\n      const parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\r\n   * Helper to setItem in browser storage, with cleanup in case of quota errors\r\n   * @param key\r\n   * @param value\r\n   */\n  setItem(key, value, correlationId) {\n    let accessTokenKeys = [];\n    const maxRetries = 20;\n    for (let i = 0; i <= maxRetries; i++) {\n      try {\n        this.browserStorage.setItem(key, value);\n        if (i > 0) {\n          // Finally update the token keys array with the tokens removed\n          this.removeAccessTokenKeys(accessTokenKeys.slice(0, i), correlationId);\n        }\n        break; // If setItem succeeds, exit the loop\n      } catch (e) {\n        const cacheError = createCacheError(e);\n        if (cacheError.errorCode === CacheErrorCodes.cacheQuotaExceeded && i < maxRetries) {\n          if (!accessTokenKeys.length) {\n            if (key === `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`) {\n              // If we are currently trying to set the token keys, use the value we're trying to set\n              accessTokenKeys = JSON.parse(value).accessToken;\n            } else {\n              // If token keys have not been initialized, get them\n              accessTokenKeys = this.getTokenKeys().accessToken;\n            }\n          }\n          if (accessTokenKeys.length <= i) {\n            // Nothing to remove, rethrow the error\n            throw cacheError;\n          }\n          // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n          this.removeAccessToken(accessTokenKeys[i], correlationId, false // Don't save token keys yet, do it at the end\n          );\n        } else {\n          // If the error is not a quota exceeded error, rethrow it\n          throw cacheError;\n        }\n      }\n    }\n  }\n  /**\r\n   * Helper to setUserData in browser storage, with cleanup in case of quota errors\r\n   * @param key\r\n   * @param value\r\n   * @param correlationId\r\n   */\n  async setUserData(key, value, correlationId, timestamp) {\n    let accessTokenKeys = [];\n    const maxRetries = 20;\n    for (let i = 0; i <= maxRetries; i++) {\n      try {\n        await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(key, value, correlationId, timestamp);\n        if (i > 0) {\n          // Finally update the token keys array with the tokens removed\n          this.removeAccessTokenKeys(accessTokenKeys.slice(0, i), correlationId);\n        }\n        break; // If setItem succeeds, exit the loop\n      } catch (e) {\n        const cacheError = createCacheError(e);\n        if (cacheError.errorCode === CacheErrorCodes.cacheQuotaExceeded && i < maxRetries) {\n          if (!accessTokenKeys.length) {\n            accessTokenKeys = this.getTokenKeys().accessToken;\n          }\n          if (accessTokenKeys.length <= i) {\n            // Nothing left to remove, rethrow the error\n            throw cacheError;\n          }\n          // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n          this.removeAccessToken(accessTokenKeys[i], correlationId, false // Don't save token keys yet, do it at the end\n          );\n        } else {\n          // If the error is not a quota exceeded error, rethrow it\n          throw cacheError;\n        }\n      }\n    }\n  }\n  /**\r\n   * Reads account from cache, deserializes it into an account entity and returns it.\r\n   * If account is not found from the key, returns null and removes key from map.\r\n   * @param accountKey\r\n   * @returns\r\n   */\n  getAccount(accountKey, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    const serializedAccount = this.browserStorage.getUserData(accountKey);\n    if (!serializedAccount) {\n      this.removeAccountKeyFromMap(accountKey, correlationId);\n      return null;\n    }\n    const parsedAccount = this.validateAndParseJson(serializedAccount);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  }\n  /**\r\n   * set account entity in the platform cache\r\n   * @param account\r\n   */\n  async setAccount(account, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    const key = account.generateAccountKey();\n    const timestamp = Date.now().toString();\n    account.lastUpdatedAt = timestamp;\n    await this.setUserData(key, JSON.stringify(account), correlationId, timestamp);\n    const wasAdded = this.addAccountKeyToMap(key, correlationId);\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage && wasAdded) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_ADDED, undefined, account.getAccountInfo());\n    }\n  }\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n  getAccountKeys() {\n    return getAccountKeys(this.browserStorage);\n  }\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n  addAccountKeyToMap(key, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys), correlationId);\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n      return true;\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n      return false;\n    }\n  }\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n  removeAccountKeyFromMap(key, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    const removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      if (accountKeys.length === 0) {\n        // If no keys left, remove the map\n        this.removeItem(StaticCacheKeys.ACCOUNT_KEYS);\n        return;\n      } else {\n        this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys), correlationId);\n      }\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  }\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n  removeAccount(key, correlationId) {\n    super.removeAccount(key, correlationId);\n    this.removeAccountKeyFromMap(key, correlationId);\n  }\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  removeAccountContext(account, correlationId) {\n    super.removeAccountContext(account, correlationId);\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_REMOVED, undefined, account.getAccountInfo());\n    }\n  }\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeIdToken(key, correlationId) {\n    super.removeIdToken(key, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    const idRemoval = tokenKeys.idToken.indexOf(key);\n    if (idRemoval > -1) {\n      this.logger.info(\"idToken removed from tokenKeys map\");\n      tokenKeys.idToken.splice(idRemoval, 1);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeAccessToken(key, correlationId, updateTokenKeys = true) {\n    super.removeAccessToken(key, correlationId);\n    updateTokenKeys && this.removeAccessTokenKeys([key], correlationId);\n  }\n  /**\r\n   * Remove access token key from the key map\r\n   * @param key\r\n   * @param correlationId\r\n   * @param tokenKeys\r\n   */\n  removeAccessTokenKeys(keys, correlationId) {\n    this.logger.trace(\"removeAccessTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    let keysRemoved = 0;\n    keys.forEach(key => {\n      const accessRemoval = tokenKeys.accessToken.indexOf(key);\n      if (accessRemoval > -1) {\n        tokenKeys.accessToken.splice(accessRemoval, 1);\n        keysRemoved++;\n      }\n    });\n    if (keysRemoved > 0) {\n      this.logger.info(`removed ${keysRemoved} accessToken keys from tokenKeys map`);\n      this.setTokenKeys(tokenKeys, correlationId);\n      return;\n    }\n  }\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeRefreshToken(key, correlationId) {\n    super.removeRefreshToken(key, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n    if (refreshRemoval > -1) {\n      this.logger.info(\"refreshToken removed from tokenKeys map\");\n      tokenKeys.refreshToken.splice(refreshRemoval, 1);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n  getTokenKeys() {\n    return getTokenKeys(this.clientId, this.browserStorage);\n  }\n  /**\r\n   * Stores the token keys in the cache\r\n   * @param tokenKeys\r\n   * @param correlationId\r\n   * @returns\r\n   */\n  setTokenKeys(tokenKeys, correlationId) {\n    if (tokenKeys.idToken.length === 0 && tokenKeys.accessToken.length === 0 && tokenKeys.refreshToken.length === 0) {\n      // If no keys left, remove the map\n      this.removeItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n      return;\n    } else {\n      this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys), correlationId);\n    }\n  }\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n  getIdTokenCredential(idTokenKey, correlationId) {\n    const value = this.browserStorage.getUserData(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeIdToken(idTokenKey, correlationId);\n      return null;\n    }\n    const parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return parsedIdToken;\n  }\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n  async setIdTokenCredential(idToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n    const timestamp = Date.now().toString();\n    idToken.lastUpdatedAt = timestamp;\n    await this.setUserData(idTokenKey, JSON.stringify(idToken), correlationId, timestamp);\n    const tokenKeys = this.getTokenKeys();\n    if (tokenKeys.idToken.indexOf(idTokenKey) === -1) {\n      this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n      tokenKeys.idToken.push(idTokenKey);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n  getAccessTokenCredential(accessTokenKey, correlationId) {\n    const value = this.browserStorage.getUserData(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeAccessTokenKeys([accessTokenKey], correlationId);\n      return null;\n    }\n    const parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !CacheHelpers.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return parsedAccessToken;\n  }\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n  async setAccessTokenCredential(accessToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n    const timestamp = Date.now().toString();\n    accessToken.lastUpdatedAt = timestamp;\n    await this.setUserData(accessTokenKey, JSON.stringify(accessToken), correlationId, timestamp);\n    const tokenKeys = this.getTokenKeys();\n    const index = tokenKeys.accessToken.indexOf(accessTokenKey);\n    if (index !== -1) {\n      tokenKeys.accessToken.splice(index, 1); // Remove existing key before pushing to the end\n    }\n    this.logger.trace(`access token ${index === -1 ? \"added to\" : \"updated in\"} map`);\n    tokenKeys.accessToken.push(accessTokenKey);\n    this.setTokenKeys(tokenKeys, correlationId);\n  }\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n  getRefreshTokenCredential(refreshTokenKey, correlationId) {\n    const value = this.browserStorage.getUserData(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeRefreshToken(refreshTokenKey, correlationId);\n      return null;\n    }\n    const parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return parsedRefreshToken;\n  }\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n  async setRefreshTokenCredential(refreshToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    const refreshTokenKey = CacheHelpers.generateCredentialKey(refreshToken);\n    const timestamp = Date.now().toString();\n    refreshToken.lastUpdatedAt = timestamp;\n    await this.setUserData(refreshTokenKey, JSON.stringify(refreshToken), correlationId, timestamp);\n    const tokenKeys = this.getTokenKeys();\n    if (tokenKeys.refreshToken.indexOf(refreshTokenKey) === -1) {\n      this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n      tokenKeys.refreshToken.push(refreshTokenKey);\n      this.setTokenKeys(tokenKeys, correlationId);\n    }\n  }\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n  getAppMetadata(appMetadataKey) {\n    const value = this.browserStorage.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return parsedMetadata;\n  }\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n  setAppMetadata(appMetadata, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata), correlationId);\n  }\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n  getServerTelemetry(serverTelemetryKey) {\n    const value = this.browserStorage.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    const parsedEntity = this.validateAndParseJson(value);\n    if (!parsedEntity || !CacheHelpers.isServerTelemetryEntity(serverTelemetryKey, parsedEntity)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return parsedEntity;\n  }\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n  setServerTelemetry(serverTelemetryKey, serverTelemetry, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry), correlationId);\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadata(key) {\n    const value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return parsedMetadata;\n    }\n    return null;\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadataKeys() {\n    const allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(key => {\n      return this.isAuthorityMetadata(key);\n    });\n  }\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n  setWrapperMetadata(wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  }\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n  getWrapperMetadata() {\n    const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  }\n  /**\r\n   *\r\n   * @param entity\r\n   */\n  setAuthorityMetadata(key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  }\n  /**\r\n   * Gets the active account\r\n   */\n  getActiveAccount(correlationId) {\n    const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountValueFilters = this.browserStorage.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters found\");\n      return null;\n    }\n    const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoFilteredBy({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId,\n        tenantId: activeAccountValueObj.tenantId\n      }, correlationId);\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  }\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n  setActiveAccount(account, correlationId) {\n    const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      const activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId,\n        tenantId: account.tenantId,\n        lastUpdatedAt: TimeUtils.nowSeconds().toString()\n      };\n      this.setItem(activeAccountKey, JSON.stringify(activeAccountValue), correlationId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n    }\n    this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\n  }\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n  getThrottlingCache(throttlingCacheKey) {\n    const value = this.browserStorage.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    const parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !CacheHelpers.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return parsedThrottlingCache;\n  }\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n  setThrottlingCache(throttlingCacheKey, throttlingCache, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache), correlationId);\n  }\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  getTemporaryCache(cacheKey, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      const itemCookie = this.cookieStorage.getItem(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    const value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        const item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  }\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n  setTemporaryCache(cacheKey, value, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.cookieStorage.setItem(key, value, undefined, this.cacheConfig.secureCookies);\n    }\n  }\n  /**\r\n   * Removes the cache item with the given key.\r\n   * @param key\r\n   */\n  removeItem(key) {\n    this.browserStorage.removeItem(key);\n  }\n  /**\r\n   * Removes the temporary cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  removeTemporaryItem(key) {\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.cookieStorage.removeItem(key);\n    }\n  }\n  /**\r\n   * Gets all keys in window.\r\n   */\n  getKeys() {\n    return this.browserStorage.getKeys();\n  }\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n  clear(correlationId) {\n    // Removes all accounts and their credentials\n    this.removeAllAccounts(correlationId);\n    this.removeAppMetadata(correlationId);\n    // Remove temp storage first to make sure any cookies are cleared\n    this.temporaryCacheStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeTemporaryItem(cacheKey);\n      }\n    });\n    // Removes all remaining MSAL cache items\n    this.browserStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.browserStorage.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  }\n  /**\r\n   * Clears all access tokes that have claims prior to saving the current one\r\n   * @param performanceClient {IPerformanceClient}\r\n   * @param correlationId {string} correlation id\r\n   * @returns\r\n   */\n  clearTokensAndKeysWithClaims(correlationId) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    let removedAccessTokens = 0;\n    tokenKeys.accessToken.forEach(key => {\n      // if the access token has claims in its key, remove the token key and the token\n      const credential = this.getAccessTokenCredential(key, correlationId);\n      if (credential?.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n        this.removeAccessToken(key, correlationId);\n        removedAccessTokens++;\n      }\n    });\n    // warn if any access tokens are removed\n    if (removedAccessTokens > 0) {\n      this.logger.warning(`${removedAccessTokens} access tokens with claims in the cache keys have been removed from the cache.`);\n    }\n  }\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n  generateCacheKey(key) {\n    const generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {\n        return key;\n      }\n      return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n    }\n    return JSON.stringify(key);\n  }\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n  resetRequestCache() {\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.VERIFIER));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  }\n  cacheAuthorizeRequest(authCodeRequest, codeVerifier) {\n    this.logger.trace(\"BrowserCacheManager.cacheAuthorizeRequest called\");\n    const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n    if (codeVerifier) {\n      const encodedVerifier = base64Encode(codeVerifier);\n      this.setTemporaryCache(TemporaryCacheKeys.VERIFIER, encodedVerifier, true);\n    }\n  }\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n  getCachedRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw createBrowserAuthError(noTokenRequestCacheError);\n    }\n    const encodedVerifier = this.getTemporaryCache(TemporaryCacheKeys.VERIFIER, true);\n    let parsedRequest;\n    let verifier = \"\";\n    try {\n      parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n      if (encodedVerifier) {\n        verifier = base64Decode(encodedVerifier);\n      }\n    } catch (e) {\n      this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n      this.logger.error(`Parsing cached token request threw with error: ${e}`);\n      throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n    }\n    return [parsedRequest, verifier];\n  }\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n  getCachedNativeRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    const parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  }\n  isInteractionInProgress(matchClientId) {\n    const clientId = this.getInteractionInProgress()?.clientId;\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  }\n  getInteractionInProgress() {\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    const value = this.getTemporaryCache(key, false);\n    try {\n      return value ? JSON.parse(value) : null;\n    } catch (e) {\n      // Remove interaction and other temp keys if interaction status can't be parsed\n      this.logger.error(`Cannot parse interaction status. Removing temporary cache items and clearing url hash. Retrying interaction should fix the error`);\n      this.removeTemporaryItem(key);\n      this.resetRequestCache();\n      clearHash(window);\n      return null;\n    }\n  }\n  setInteractionInProgress(inProgress, type = INTERACTION_TYPE.SIGNIN) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw createBrowserAuthError(interactionInProgress);\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, JSON.stringify({\n          clientId: this.clientId,\n          type\n        }), false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress()?.clientId === this.clientId) {\n      this.removeTemporaryItem(key);\n    }\n  }\n  /**\r\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n   * @param result\r\n   * @param request\r\n   */\n  async hydrateCache(result, request) {\n    const idTokenEntity = CacheHelpers.createIdTokenEntity(result.account?.homeAccountId, result.account?.environment, result.idToken, this.clientId, result.tenantId);\n    let claimsHash;\n    if (request.claims) {\n      claimsHash = await this.cryptoImpl.hashString(request.claims);\n    }\n    /**\r\n     * meta data for cache stores time in seconds from epoch\r\n     * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\r\n     * We need to map these for the cache when building tokens from AuthenticationResult\r\n     *\r\n     * The next MSAL VFuture should map these both to same value if possible\r\n     */\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity(result.account?.homeAccountId, result.account.environment, result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"),\n    // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date\n    result.expiresOn ? TimeUtils.toSecondsFromDate(result.expiresOn) : 0, result.extExpiresOn ? TimeUtils.toSecondsFromDate(result.extExpiresOn) : 0, base64Decode, undefined,\n    // refreshOn\n    result.tokenType, undefined,\n    // userAssertionHash\n    request.sshKid, request.claims, claimsHash);\n    const cacheRecord = {\n      idToken: idTokenEntity,\n      accessToken: accessTokenEntity\n    };\n    return this.saveCacheRecord(cacheRecord, result.correlationId);\n  }\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord {CacheRecord}\r\n   * @param storeInCache {?StoreInCache}\r\n   * @param correlationId {?string} correlation id\r\n   */\n  async saveCacheRecord(cacheRecord, correlationId, storeInCache) {\n    try {\n      await super.saveCacheRecord(cacheRecord, correlationId, storeInCache);\n    } catch (e) {\n      if (e instanceof CacheError && this.performanceClient && correlationId) {\n        try {\n          const tokenKeys = this.getTokenKeys();\n          this.performanceClient.addFields({\n            cacheRtCount: tokenKeys.refreshToken.length,\n            cacheIdCount: tokenKeys.idToken.length,\n            cacheAtCount: tokenKeys.accessToken.length\n          }, correlationId);\n        } catch (e) {}\n      }\n      throw e;\n    }\n  }\n}\n/**\r\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n * @param cacheLocation\r\n */\nfunction getStorageImplementation(clientId, cacheLocation, logger, performanceClient) {\n  try {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n        return new LocalStorage(clientId, logger, performanceClient);\n      case BrowserCacheLocation.SessionStorage:\n        return new SessionStorage();\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        break;\n    }\n  } catch (e) {\n    logger.error(e);\n  }\n  return new MemoryStorage();\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger, performanceClient, eventHandler) => {\n  const cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger, performanceClient, eventHandler);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["BrowserCacheManager","CacheManager","constructor","clientId","cacheConfig","cryptoImpl","logger","performanceClient","eventHandler","staticAuthorityOptions","internalStorage","MemoryStorage","browserStorage","getStorageImplementation","cacheLocation","temporaryCacheStorage","temporaryCacheLocation","cookieStorage","CookieStorage","initialize","correlationId","trackVersionChanges","previousVersion","getItem","StaticCacheKeys","VERSION","info","addFields","previousLibraryVersion","version","setItem","validateAndParseJson","jsonValue","parsedJson","JSON","parse","error","key","value","accessTokenKeys","maxRetries","i","removeAccessTokenKeys","slice","e","cacheError","createCacheError","errorCode","CacheErrorCodes","cacheQuotaExceeded","length","TOKEN_KEYS","accessToken","getTokenKeys","removeAccessToken","setUserData","timestamp","invokeAsync","bind","PerformanceEvents","SetUserData","getAccount","accountKey","trace","serializedAccount","getUserData","removeAccountKeyFromMap","parsedAccount","AccountEntity","isAccountEntity","toObject","setAccount","account","generateAccountKey","Date","now","toString","lastUpdatedAt","stringify","wasAdded","addAccountKeyToMap","BrowserCacheLocation","LocalStorage","emitEvent","EventType","ACCOUNT_ADDED","undefined","getAccountInfo","getAccountKeys","tracePii","accountKeys","indexOf","push","ACCOUNT_KEYS","verbose","removalIndex","splice","removeItem","removeAccount","removeAccountContext","ACCOUNT_REMOVED","removeIdToken","tokenKeys","idRemoval","idToken","setTokenKeys","updateTokenKeys","keys","keysRemoved","forEach","accessRemoval","removeRefreshToken","refreshRemoval","refreshToken","getIdTokenCredential","idTokenKey","parsedIdToken","CacheHelpers","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","isAccessTokenEntity","setAccessTokenCredential","index","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","parsedEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","allKeys","getKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","InMemoryCacheKeys","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","Constants","EMPTY_STRING","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","PersistentCacheKeys","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountValueObj","getAccountInfoFilteredBy","homeAccountId","localAccountId","tenantId","setActiveAccount","activeAccountKey","activeAccountValue","TimeUtils","nowSeconds","ACTIVE_ACCOUNT_CHANGED","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","cacheKey","generateKey","storeAuthStateInCookie","itemCookie","item","setTemporaryCache","secureCookies","removeTemporaryItem","clear","removeAllAccounts","removeAppMetadata","CACHE_PREFIX","clearTokensAndKeysWithClaims","addQueueMeasurement","ClearTokensAndKeysWithClaims","removedAccessTokens","credential","requestedClaimsHash","includes","toLowerCase","warning","generatedKey","StringUtils","startsWith","resetRequestCache","TemporaryCacheKeys","REQUEST_PARAMS","VERIFIER","ORIGIN_URI","URL_HASH","NATIVE_REQUEST","setInteractionInProgress","cacheAuthorizeRequest","authCodeRequest","codeVerifier","encodedValue","base64Encode","encodedVerifier","getCachedRequest","encodedTokenRequest","createBrowserAuthError","noTokenRequestCacheError","parsedRequest","verifier","base64Decode","errorPii","unableToParseTokenRequestCacheError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","clearHash","window","inProgress","type","INTERACTION_TYPE","SIGNIN","interactionInProgress","hydrateCache","result","request","idTokenEntity","createIdTokenEntity","environment","claimsHash","claims","hashString","accessTokenEntity","createAccessTokenEntity","scopes","join","expiresOn","toSecondsFromDate","extExpiresOn","tokenType","sshKid","cacheRecord","saveCacheRecord","storeInCache","CacheError","cacheRtCount","cacheIdCount","cacheAtCount","SessionStorage","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","cacheMigrationEnabled","claimsBasedCachingEnabled","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["/Users/user/workspace/eventhorizon/node_modules/@azure/msal-browser/src/cache/BrowserCacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccessTokenEntity,\n    AccountEntity,\n    AccountInfo,\n    ActiveAccountFilters,\n    AppMetadataEntity,\n    AuthenticationScheme,\n    AuthorityMetadataEntity,\n    CacheError,\n    CacheErrorCodes,\n    CacheHelpers,\n    CacheManager,\n    CacheRecord,\n    CommonAuthorizationUrlRequest,\n    Constants,\n    createCacheError,\n    DEFAULT_CRYPTO_IMPLEMENTATION,\n    ICrypto,\n    IdTokenEntity,\n    invokeAsync,\n    IPerformanceClient,\n    Logger,\n    PerformanceEvents,\n    PersistentCacheKeys,\n    RefreshTokenEntity,\n    ServerTelemetryEntity,\n    StaticAuthorityOptions,\n    StoreInCache,\n    StringUtils,\n    ThrottlingEntity,\n    TimeUtils,\n    TokenKeys,\n} from \"@azure/msal-common/browser\";\nimport { CacheOptions } from \"../config/Configuration.js\";\nimport {\n    BrowserAuthErrorCodes,\n    createBrowserAuthError,\n} from \"../error/BrowserAuthError.js\";\nimport {\n    BrowserCacheLocation,\n    InMemoryCacheKeys,\n    INTERACTION_TYPE,\n    StaticCacheKeys,\n    TemporaryCacheKeys,\n} from \"../utils/BrowserConstants.js\";\nimport { LocalStorage } from \"./LocalStorage.js\";\nimport { SessionStorage } from \"./SessionStorage.js\";\nimport { MemoryStorage } from \"./MemoryStorage.js\";\nimport { IWindowStorage } from \"./IWindowStorage.js\";\nimport { PlatformAuthRequest } from \"../broker/nativeBroker/PlatformAuthRequest.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { SilentRequest } from \"../request/SilentRequest.js\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest.js\";\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\nimport { PopupRequest } from \"../request/PopupRequest.js\";\nimport { base64Decode } from \"../encode/Base64Decode.js\";\nimport { base64Encode } from \"../encode/Base64Encode.js\";\nimport { CookieStorage } from \"./CookieStorage.js\";\nimport { getAccountKeys, getTokenKeys } from \"./CacheHelpers.js\";\nimport { EventType } from \"../event/EventType.js\";\nimport { EventHandler } from \"../event/EventHandler.js\";\nimport { clearHash } from \"../utils/BrowserUtils.js\";\nimport { version } from \"../packageMetadata.js\";\n\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nexport class BrowserCacheManager extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    protected cacheConfig: Required<CacheOptions>;\n    // Window storage object (either local or sessionStorage)\n    protected browserStorage: IWindowStorage<string>;\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\n    protected internalStorage: MemoryStorage<string>;\n    // Temporary cache\n    protected temporaryCacheStorage: IWindowStorage<string>;\n    // Cookie storage\n    protected cookieStorage: CookieStorage;\n    // Logger instance\n    protected logger: Logger;\n    // Event Handler\n    private eventHandler: EventHandler;\n\n    constructor(\n        clientId: string,\n        cacheConfig: Required<CacheOptions>,\n        cryptoImpl: ICrypto,\n        logger: Logger,\n        performanceClient: IPerformanceClient,\n        eventHandler: EventHandler,\n        staticAuthorityOptions?: StaticAuthorityOptions\n    ) {\n        super(\n            clientId,\n            cryptoImpl,\n            logger,\n            performanceClient,\n            staticAuthorityOptions\n        );\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = getStorageImplementation(\n            clientId,\n            cacheConfig.cacheLocation,\n            logger,\n            performanceClient\n        );\n        this.temporaryCacheStorage = getStorageImplementation(\n            clientId,\n            cacheConfig.temporaryCacheLocation,\n            logger,\n            performanceClient\n        );\n        this.cookieStorage = new CookieStorage();\n        this.eventHandler = eventHandler;\n    }\n\n    async initialize(correlationId: string): Promise<void> {\n        await this.browserStorage.initialize(correlationId);\n        this.trackVersionChanges(correlationId);\n    }\n\n    /**\n     * Tracks upgrades and downgrades for telemetry and debugging purposes\n     */\n    private trackVersionChanges(correlationId: string): void {\n        const previousVersion = this.browserStorage.getItem(\n            StaticCacheKeys.VERSION\n        );\n        if (previousVersion) {\n            this.logger.info(\n                `MSAL.js was last initialized by version: ${previousVersion}`\n            );\n            this.performanceClient.addFields(\n                { previousLibraryVersion: previousVersion },\n                correlationId\n            );\n        }\n\n        if (previousVersion !== version) {\n            this.setItem(StaticCacheKeys.VERSION, version, correlationId);\n        }\n    }\n\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    protected validateAndParseJson(jsonValue: string): object | null {\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return parsedJson && typeof parsedJson === \"object\"\n                ? parsedJson\n                : null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * Helper to setItem in browser storage, with cleanup in case of quota errors\n     * @param key\n     * @param value\n     */\n    setItem(key: string, value: string, correlationId: string): void {\n        let accessTokenKeys: Array<string> = [];\n        const maxRetries = 20;\n        for (let i = 0; i <= maxRetries; i++) {\n            try {\n                this.browserStorage.setItem(key, value);\n                if (i > 0) {\n                    // Finally update the token keys array with the tokens removed\n                    this.removeAccessTokenKeys(\n                        accessTokenKeys.slice(0, i),\n                        correlationId\n                    );\n                }\n                break; // If setItem succeeds, exit the loop\n            } catch (e) {\n                const cacheError = createCacheError(e);\n                if (\n                    cacheError.errorCode ===\n                        CacheErrorCodes.cacheQuotaExceeded &&\n                    i < maxRetries\n                ) {\n                    if (!accessTokenKeys.length) {\n                        if (\n                            key ===\n                            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`\n                        ) {\n                            // If we are currently trying to set the token keys, use the value we're trying to set\n                            accessTokenKeys = (JSON.parse(value) as TokenKeys)\n                                .accessToken;\n                        } else {\n                            // If token keys have not been initialized, get them\n                            accessTokenKeys = this.getTokenKeys().accessToken;\n                        }\n                    }\n                    if (accessTokenKeys.length <= i) {\n                        // Nothing to remove, rethrow the error\n                        throw cacheError;\n                    }\n                    // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n                    this.removeAccessToken(\n                        accessTokenKeys[i],\n                        correlationId,\n                        false // Don't save token keys yet, do it at the end\n                    );\n                } else {\n                    // If the error is not a quota exceeded error, rethrow it\n                    throw cacheError;\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper to setUserData in browser storage, with cleanup in case of quota errors\n     * @param key\n     * @param value\n     * @param correlationId\n     */\n    async setUserData(\n        key: string,\n        value: string,\n        correlationId: string,\n        timestamp: string\n    ): Promise<void> {\n        let accessTokenKeys: Array<string> = [];\n        const maxRetries = 20;\n        for (let i = 0; i <= maxRetries; i++) {\n            try {\n                await invokeAsync(\n                    this.browserStorage.setUserData.bind(this.browserStorage),\n                    PerformanceEvents.SetUserData,\n                    this.logger,\n                    this.performanceClient\n                )(key, value, correlationId, timestamp);\n                if (i > 0) {\n                    // Finally update the token keys array with the tokens removed\n                    this.removeAccessTokenKeys(\n                        accessTokenKeys.slice(0, i),\n                        correlationId\n                    );\n                }\n                break; // If setItem succeeds, exit the loop\n            } catch (e) {\n                const cacheError = createCacheError(e);\n                if (\n                    cacheError.errorCode ===\n                        CacheErrorCodes.cacheQuotaExceeded &&\n                    i < maxRetries\n                ) {\n                    if (!accessTokenKeys.length) {\n                        accessTokenKeys = this.getTokenKeys().accessToken;\n                    }\n                    if (accessTokenKeys.length <= i) {\n                        // Nothing left to remove, rethrow the error\n                        throw cacheError;\n                    }\n                    // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n                    this.removeAccessToken(\n                        accessTokenKeys[i],\n                        correlationId,\n                        false // Don't save token keys yet, do it at the end\n                    );\n                } else {\n                    // If the error is not a quota exceeded error, rethrow it\n                    throw cacheError;\n                }\n            }\n        }\n    }\n\n    /**\n     * Reads account from cache, deserializes it into an account entity and returns it.\n     * If account is not found from the key, returns null and removes key from map.\n     * @param accountKey\n     * @returns\n     */\n    getAccount(\n        accountKey: string,\n        correlationId: string\n    ): AccountEntity | null {\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\n        const serializedAccount = this.browserStorage.getUserData(accountKey);\n        if (!serializedAccount) {\n            this.removeAccountKeyFromMap(accountKey, correlationId);\n            return null;\n        }\n\n        const parsedAccount = this.validateAndParseJson(serializedAccount);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            return null;\n        }\n\n        return CacheManager.toObject<AccountEntity>(\n            new AccountEntity(),\n            parsedAccount\n        );\n    }\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    async setAccount(\n        account: AccountEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = account.generateAccountKey();\n        const timestamp = Date.now().toString();\n        account.lastUpdatedAt = timestamp;\n        await this.setUserData(\n            key,\n            JSON.stringify(account),\n            correlationId,\n            timestamp\n        );\n        const wasAdded = this.addAccountKeyToMap(key, correlationId);\n\n        /**\n         * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\n         */\n        if (\n            this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage &&\n            wasAdded\n        ) {\n            this.eventHandler.emitEvent(\n                EventType.ACCOUNT_ADDED,\n                undefined,\n                account.getAccountInfo()\n            );\n        }\n    }\n\n    /**\n     * Returns the array of account keys currently cached\n     * @returns\n     */\n    getAccountKeys(): Array<string> {\n        return getAccountKeys(this.browserStorage);\n    }\n\n    /**\n     * Add a new account to the key map\n     * @param key\n     */\n    addAccountKeyToMap(key: string, correlationId: string): boolean {\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.addAccountKeyToMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        if (accountKeys.indexOf(key) === -1) {\n            // Only add key if it does not already exist in the map\n            accountKeys.push(key);\n            this.setItem(\n                StaticCacheKeys.ACCOUNT_KEYS,\n                JSON.stringify(accountKeys),\n                correlationId\n            );\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key added\"\n            );\n            return true;\n        } else {\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key already exists in map\"\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Remove an account from the key map\n     * @param key\n     */\n    removeAccountKeyFromMap(key: string, correlationId: string): void {\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        const removalIndex = accountKeys.indexOf(key);\n        if (removalIndex > -1) {\n            accountKeys.splice(removalIndex, 1);\n            if (accountKeys.length === 0) {\n                // If no keys left, remove the map\n                this.removeItem(StaticCacheKeys.ACCOUNT_KEYS);\n                return;\n            } else {\n                this.setItem(\n                    StaticCacheKeys.ACCOUNT_KEYS,\n                    JSON.stringify(accountKeys),\n                    correlationId\n                );\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap account key removed\"\n            );\n        } else {\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\"\n            );\n        }\n    }\n\n    /**\n     * Extends inherited removeAccount function to include removal of the account key from the map\n     * @param key\n     */\n    removeAccount(key: string, correlationId: string): void {\n        super.removeAccount(key, correlationId);\n        this.removeAccountKeyFromMap(key, correlationId);\n    }\n\n    /**\n     * Removes credentials associated with the provided account\n     * @param account\n     */\n    removeAccountContext(account: AccountEntity, correlationId: string): void {\n        super.removeAccountContext(account, correlationId);\n\n        /**\n         * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\n         */\n        if (\n            this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage\n        ) {\n            this.eventHandler.emitEvent(\n                EventType.ACCOUNT_REMOVED,\n                undefined,\n                account.getAccountInfo()\n            );\n        }\n    }\n\n    /**\n     * Removes given idToken from the cache and from the key map\n     * @param key\n     */\n    removeIdToken(key: string, correlationId: string): void {\n        super.removeIdToken(key, correlationId);\n        const tokenKeys = this.getTokenKeys();\n        const idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n            this.logger.info(\"idToken removed from tokenKeys map\");\n            tokenKeys.idToken.splice(idRemoval, 1);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * Removes given accessToken from the cache and from the key map\n     * @param key\n     */\n    removeAccessToken(\n        key: string,\n        correlationId: string,\n        updateTokenKeys: boolean = true\n    ): void {\n        super.removeAccessToken(key, correlationId);\n        updateTokenKeys && this.removeAccessTokenKeys([key], correlationId);\n    }\n\n    /**\n     * Remove access token key from the key map\n     * @param key\n     * @param correlationId\n     * @param tokenKeys\n     */\n    removeAccessTokenKeys(keys: Array<string>, correlationId: string): void {\n        this.logger.trace(\"removeAccessTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n        let keysRemoved = 0;\n        keys.forEach((key) => {\n            const accessRemoval = tokenKeys.accessToken.indexOf(key);\n            if (accessRemoval > -1) {\n                tokenKeys.accessToken.splice(accessRemoval, 1);\n                keysRemoved++;\n            }\n        });\n\n        if (keysRemoved > 0) {\n            this.logger.info(\n                `removed ${keysRemoved} accessToken keys from tokenKeys map`\n            );\n            this.setTokenKeys(tokenKeys, correlationId);\n            return;\n        }\n    }\n\n    /**\n     * Removes given refreshToken from the cache and from the key map\n     * @param key\n     */\n    removeRefreshToken(key: string, correlationId: string): void {\n        super.removeRefreshToken(key, correlationId);\n        const tokenKeys = this.getTokenKeys();\n        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n            this.logger.info(\"refreshToken removed from tokenKeys map\");\n            tokenKeys.refreshToken.splice(refreshRemoval, 1);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * Gets the keys for the cached tokens associated with this clientId\n     * @returns\n     */\n    getTokenKeys(): TokenKeys {\n        return getTokenKeys(this.clientId, this.browserStorage);\n    }\n\n    /**\n     * Stores the token keys in the cache\n     * @param tokenKeys\n     * @param correlationId\n     * @returns\n     */\n    setTokenKeys(tokenKeys: TokenKeys, correlationId: string): void {\n        if (\n            tokenKeys.idToken.length === 0 &&\n            tokenKeys.accessToken.length === 0 &&\n            tokenKeys.refreshToken.length === 0\n        ) {\n            // If no keys left, remove the map\n            this.removeItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n            return;\n        } else {\n            this.setItem(\n                `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\n                JSON.stringify(tokenKeys),\n                correlationId\n            );\n        }\n    }\n\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(\n        idTokenKey: string,\n        correlationId: string\n    ): IdTokenEntity | null {\n        const value = this.browserStorage.getUserData(idTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            this.removeIdToken(idTokenKey, correlationId);\n            return null;\n        }\n\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getIdTokenCredential: cache hit\"\n        );\n        return parsedIdToken as IdTokenEntity;\n    }\n\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    async setIdTokenCredential(\n        idToken: IdTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n        const timestamp = Date.now().toString();\n        idToken.lastUpdatedAt = timestamp;\n\n        await this.setUserData(\n            idTokenKey,\n            JSON.stringify(idToken),\n            correlationId,\n            timestamp\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        if (tokenKeys.idToken.indexOf(idTokenKey) === -1) {\n            this.logger.info(\n                \"BrowserCacheManager: addTokenKey - idToken added to map\"\n            );\n            tokenKeys.idToken.push(idTokenKey);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(\n        accessTokenKey: string,\n        correlationId: string\n    ): AccessTokenEntity | null {\n        const value = this.browserStorage.getUserData(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            this.removeAccessTokenKeys([accessTokenKey], correlationId);\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (\n            !parsedAccessToken ||\n            !CacheHelpers.isAccessTokenEntity(parsedAccessToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getAccessTokenCredential: cache hit\"\n        );\n        return parsedAccessToken as AccessTokenEntity;\n    }\n\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    async setAccessTokenCredential(\n        accessToken: AccessTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\n            \"BrowserCacheManager.setAccessTokenCredential called\"\n        );\n        const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n        const timestamp = Date.now().toString();\n        accessToken.lastUpdatedAt = timestamp;\n\n        await this.setUserData(\n            accessTokenKey,\n            JSON.stringify(accessToken),\n            correlationId,\n            timestamp\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        const index = tokenKeys.accessToken.indexOf(accessTokenKey);\n        if (index !== -1) {\n            tokenKeys.accessToken.splice(index, 1); // Remove existing key before pushing to the end\n        }\n        this.logger.trace(\n            `access token ${index === -1 ? \"added to\" : \"updated in\"} map`\n        );\n        tokenKeys.accessToken.push(accessTokenKey);\n        this.setTokenKeys(tokenKeys, correlationId);\n    }\n\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(\n        refreshTokenKey: string,\n        correlationId: string\n    ): RefreshTokenEntity | null {\n        const value = this.browserStorage.getUserData(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            this.removeRefreshToken(refreshTokenKey, correlationId);\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (\n            !parsedRefreshToken ||\n            !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getRefreshTokenCredential: cache hit\"\n        );\n        return parsedRefreshToken as RefreshTokenEntity;\n    }\n\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    async setRefreshTokenCredential(\n        refreshToken: RefreshTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\n            \"BrowserCacheManager.setRefreshTokenCredential called\"\n        );\n        const refreshTokenKey =\n            CacheHelpers.generateCredentialKey(refreshToken);\n        const timestamp = Date.now().toString();\n        refreshToken.lastUpdatedAt = timestamp;\n\n        await this.setUserData(\n            refreshTokenKey,\n            JSON.stringify(refreshToken),\n            correlationId,\n            timestamp\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        if (tokenKeys.refreshToken.indexOf(refreshTokenKey) === -1) {\n            this.logger.info(\n                \"BrowserCacheManager: addTokenKey - refreshToken added to map\"\n            );\n            tokenKeys.refreshToken.push(refreshTokenKey);\n            this.setTokenKeys(tokenKeys, correlationId);\n        }\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const value = this.browserStorage.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            !parsedMetadata ||\n            !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return parsedMetadata as AppMetadataEntity;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(\n        appMetadata: AppMetadataEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n        this.setItem(\n            appMetadataKey,\n            JSON.stringify(appMetadata),\n            correlationId\n        );\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(\n        serverTelemetryKey: string\n    ): ServerTelemetryEntity | null {\n        const value = this.browserStorage.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedEntity = this.validateAndParseJson(value);\n        if (\n            !parsedEntity ||\n            !CacheHelpers.isServerTelemetryEntity(\n                serverTelemetryKey,\n                parsedEntity\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return parsedEntity as ServerTelemetryEntity;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.setItem(\n            serverTelemetryKey,\n            JSON.stringify(serverTelemetry),\n            correlationId\n        );\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            parsedMetadata &&\n            CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: cache hit\"\n            );\n            return parsedMetadata as AuthorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU\n     * @param wrapperVersion\n     */\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(\n            InMemoryCacheKeys.WRAPPER_VER,\n            wrapperVersion\n        );\n    }\n\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata(): [string, string] {\n        const sku =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) ||\n            Constants.EMPTY_STRING;\n        const version =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) ||\n            Constants.EMPTY_STRING;\n        return [sku, version];\n    }\n\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n\n    /**\n     * Gets the active account\n     */\n    getActiveAccount(correlationId: string): AccountInfo | null {\n        const activeAccountKeyFilters = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        const activeAccountValueFilters = this.browserStorage.getItem(\n            activeAccountKeyFilters\n        );\n        if (!activeAccountValueFilters) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: No active account filters found\"\n            );\n            return null;\n        }\n        const activeAccountValueObj = this.validateAndParseJson(\n            activeAccountValueFilters\n        ) as AccountInfo;\n        if (activeAccountValueObj) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: Active account filters schema found\"\n            );\n            return this.getAccountInfoFilteredBy(\n                {\n                    homeAccountId: activeAccountValueObj.homeAccountId,\n                    localAccountId: activeAccountValueObj.localAccountId,\n                    tenantId: activeAccountValueObj.tenantId,\n                },\n                correlationId\n            );\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getActiveAccount: No active account found\"\n        );\n        return null;\n    }\n\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null, correlationId: string): void {\n        const activeAccountKey = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            const activeAccountValue: ActiveAccountFilters = {\n                homeAccountId: account.homeAccountId,\n                localAccountId: account.localAccountId,\n                tenantId: account.tenantId,\n                lastUpdatedAt: TimeUtils.nowSeconds().toString(),\n            };\n            this.setItem(\n                activeAccountKey,\n                JSON.stringify(activeAccountValue),\n                correlationId\n            );\n        } else {\n            this.logger.verbose(\n                \"setActiveAccount: No account passed, active account not set\"\n            );\n            this.browserStorage.removeItem(activeAccountKey);\n        }\n        this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const value = this.browserStorage.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (\n            !parsedThrottlingCache ||\n            !CacheHelpers.isThrottlingEntity(\n                throttlingCacheKey,\n                parsedThrottlingCache\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return parsedThrottlingCache as ThrottlingEntity;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.setItem(\n            throttlingCacheKey,\n            JSON.stringify(throttlingCache),\n            correlationId\n        );\n    }\n\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.cookieStorage.getItem(key);\n            if (itemCookie) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\"\n                );\n                return itemCookie;\n            }\n        }\n\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (\n                this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage\n            ) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\n                        \"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\"\n                    );\n                    return item;\n                }\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\"\n            );\n            return null;\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\"\n        );\n        return value;\n    }\n\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(\n        cacheKey: string,\n        value: string,\n        generateKey?: boolean\n    ): void {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\"\n            );\n            this.cookieStorage.setItem(\n                key,\n                value,\n                undefined,\n                this.cacheConfig.secureCookies\n            );\n        }\n    }\n\n    /**\n     * Removes the cache item with the given key.\n     * @param key\n     */\n    removeItem(key: string): void {\n        this.browserStorage.removeItem(key);\n    }\n\n    /**\n     * Removes the temporary cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeTemporaryItem(key: string): void {\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\"\n            );\n            this.cookieStorage.removeItem(key);\n        }\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        return this.browserStorage.getKeys();\n    }\n\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    clear(correlationId: string): void {\n        // Removes all accounts and their credentials\n        this.removeAllAccounts(correlationId);\n        this.removeAppMetadata(correlationId);\n\n        // Remove temp storage first to make sure any cookies are cleared\n        this.temporaryCacheStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.removeTemporaryItem(cacheKey);\n            }\n        });\n\n        // Removes all remaining MSAL cache items\n        this.browserStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.browserStorage.removeItem(cacheKey);\n            }\n        });\n\n        this.internalStorage.clear();\n    }\n\n    /**\n     * Clears all access tokes that have claims prior to saving the current one\n     * @param performanceClient {IPerformanceClient}\n     * @param correlationId {string} correlation id\n     * @returns\n     */\n    clearTokensAndKeysWithClaims(correlationId: string): void {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.ClearTokensAndKeysWithClaims,\n            correlationId\n        );\n\n        const tokenKeys = this.getTokenKeys();\n        let removedAccessTokens = 0;\n        tokenKeys.accessToken.forEach((key: string) => {\n            // if the access token has claims in its key, remove the token key and the token\n            const credential = this.getAccessTokenCredential(\n                key,\n                correlationId\n            );\n            if (\n                credential?.requestedClaimsHash &&\n                key.includes(credential.requestedClaimsHash.toLowerCase())\n            ) {\n                this.removeAccessToken(key, correlationId);\n                removedAccessTokens++;\n            }\n        });\n\n        // warn if any access tokens are removed\n        if (removedAccessTokens > 0) {\n            this.logger.warning(\n                `${removedAccessTokens} access tokens with claims in the cache keys have been removed from the cache.`\n            );\n        }\n    }\n\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key: string): string {\n        const generatedKey = this.validateAndParseJson(key);\n        if (!generatedKey) {\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {\n                return key;\n            }\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n        }\n\n        return JSON.stringify(key);\n    }\n\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(): void {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.VERIFIER)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.URL_HASH)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)\n        );\n        this.setInteractionInProgress(false);\n    }\n\n    cacheAuthorizeRequest(\n        authCodeRequest: CommonAuthorizationUrlRequest,\n        codeVerifier?: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.cacheAuthorizeRequest called\");\n\n        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            encodedValue,\n            true\n        );\n\n        if (codeVerifier) {\n            const encodedVerifier = base64Encode(codeVerifier);\n            this.setTemporaryCache(\n                TemporaryCacheKeys.VERIFIER,\n                encodedVerifier,\n                true\n            );\n        }\n    }\n\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(): [CommonAuthorizationUrlRequest, string] {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            true\n        );\n        if (!encodedTokenRequest) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.noTokenRequestCacheError\n            );\n        }\n        const encodedVerifier = this.getTemporaryCache(\n            TemporaryCacheKeys.VERIFIER,\n            true\n        );\n\n        let parsedRequest: CommonAuthorizationUrlRequest;\n        let verifier = \"\";\n        try {\n            parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n            if (encodedVerifier) {\n                verifier = base64Decode(encodedVerifier);\n            }\n        } catch (e) {\n            this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n            this.logger.error(\n                `Parsing cached token request threw with error: ${e}`\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToParseTokenRequestCacheError\n            );\n        }\n\n        return [parsedRequest, verifier];\n    }\n\n    /**\n     * Gets cached native request for redirect flows\n     */\n    getCachedNativeRequest(): PlatformAuthRequest | null {\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n        const cachedRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.NATIVE_REQUEST,\n            true\n        );\n        if (!cachedRequest) {\n            this.logger.trace(\n                \"BrowserCacheManager.getCachedNativeRequest: No cached native request found\"\n            );\n            return null;\n        }\n\n        const parsedRequest = this.validateAndParseJson(\n            cachedRequest\n        ) as PlatformAuthRequest;\n        if (!parsedRequest) {\n            this.logger.error(\n                \"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\"\n            );\n            return null;\n        }\n\n        return parsedRequest;\n    }\n\n    isInteractionInProgress(matchClientId?: boolean): boolean {\n        const clientId = this.getInteractionInProgress()?.clientId;\n\n        if (matchClientId) {\n            return clientId === this.clientId;\n        } else {\n            return !!clientId;\n        }\n    }\n\n    getInteractionInProgress(): {\n        clientId: string;\n        type: INTERACTION_TYPE;\n    } | null {\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        const value = this.getTemporaryCache(key, false);\n        try {\n            return value ? JSON.parse(value) : null;\n        } catch (e) {\n            // Remove interaction and other temp keys if interaction status can't be parsed\n            this.logger.error(\n                `Cannot parse interaction status. Removing temporary cache items and clearing url hash. Retrying interaction should fix the error`\n            );\n            this.removeTemporaryItem(key);\n            this.resetRequestCache();\n            clearHash(window);\n            return null;\n        }\n    }\n\n    setInteractionInProgress(\n        inProgress: boolean,\n        type: INTERACTION_TYPE = INTERACTION_TYPE.SIGNIN\n    ): void {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.interactionInProgress\n                );\n            } else {\n                // No interaction is in progress\n                this.setTemporaryCache(\n                    key,\n                    JSON.stringify({ clientId: this.clientId, type }),\n                    false\n                );\n            }\n        } else if (\n            !inProgress &&\n            this.getInteractionInProgress()?.clientId === this.clientId\n        ) {\n            this.removeTemporaryItem(key);\n        }\n    }\n\n    /**\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n     * @param result\n     * @param request\n     */\n    async hydrateCache(\n        result: AuthenticationResult,\n        request:\n            | SilentRequest\n            | SsoSilentRequest\n            | RedirectRequest\n            | PopupRequest\n    ): Promise<void> {\n        const idTokenEntity = CacheHelpers.createIdTokenEntity(\n            result.account?.homeAccountId,\n            result.account?.environment,\n            result.idToken,\n            this.clientId,\n            result.tenantId\n        );\n\n        let claimsHash;\n        if (request.claims) {\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\n        }\n\n        /**\n         * meta data for cache stores time in seconds from epoch\n         * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\n         * We need to map these for the cache when building tokens from AuthenticationResult\n         *\n         * The next MSAL VFuture should map these both to same value if possible\n         */\n\n        const accessTokenEntity = CacheHelpers.createAccessTokenEntity(\n            result.account?.homeAccountId,\n            result.account.environment,\n            result.accessToken,\n            this.clientId,\n            result.tenantId,\n            result.scopes.join(\" \"),\n            // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date\n            result.expiresOn\n                ? TimeUtils.toSecondsFromDate(result.expiresOn)\n                : 0,\n            result.extExpiresOn\n                ? TimeUtils.toSecondsFromDate(result.extExpiresOn)\n                : 0,\n            base64Decode,\n            undefined, // refreshOn\n            result.tokenType as AuthenticationScheme,\n            undefined, // userAssertionHash\n            request.sshKid,\n            request.claims,\n            claimsHash\n        );\n\n        const cacheRecord = {\n            idToken: idTokenEntity,\n            accessToken: accessTokenEntity,\n        };\n        return this.saveCacheRecord(cacheRecord, result.correlationId);\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord {CacheRecord}\n     * @param storeInCache {?StoreInCache}\n     * @param correlationId {?string} correlation id\n     */\n    async saveCacheRecord(\n        cacheRecord: CacheRecord,\n        correlationId: string,\n        storeInCache?: StoreInCache\n    ): Promise<void> {\n        try {\n            await super.saveCacheRecord(\n                cacheRecord,\n                correlationId,\n                storeInCache\n            );\n        } catch (e) {\n            if (\n                e instanceof CacheError &&\n                this.performanceClient &&\n                correlationId\n            ) {\n                try {\n                    const tokenKeys = this.getTokenKeys();\n\n                    this.performanceClient.addFields(\n                        {\n                            cacheRtCount: tokenKeys.refreshToken.length,\n                            cacheIdCount: tokenKeys.idToken.length,\n                            cacheAtCount: tokenKeys.accessToken.length,\n                        },\n                        correlationId\n                    );\n                } catch (e) {}\n            }\n\n            throw e;\n        }\n    }\n}\n\n/**\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n * @param cacheLocation\n */\nfunction getStorageImplementation(\n    clientId: string,\n    cacheLocation: BrowserCacheLocation | string,\n    logger: Logger,\n    performanceClient: IPerformanceClient\n): IWindowStorage<string> {\n    try {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n                return new LocalStorage(clientId, logger, performanceClient);\n            case BrowserCacheLocation.SessionStorage:\n                return new SessionStorage();\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                break;\n        }\n    } catch (e) {\n        logger.error(e as string);\n    }\n\n    return new MemoryStorage();\n}\n\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (\n    clientId: string,\n    logger: Logger,\n    performanceClient: IPerformanceClient,\n    eventHandler: EventHandler\n): BrowserCacheManager => {\n    const cacheOptions: Required<CacheOptions> = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false,\n        cacheMigrationEnabled: false,\n        claimsBasedCachingEnabled: false,\n    };\n    return new BrowserCacheManager(\n        clientId,\n        cacheOptions,\n        DEFAULT_CRYPTO_IMPLEMENTATION,\n        logger,\n        performanceClient,\n        eventHandler\n    );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}