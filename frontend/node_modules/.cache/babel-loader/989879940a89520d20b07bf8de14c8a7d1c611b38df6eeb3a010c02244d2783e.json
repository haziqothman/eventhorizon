{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isNodeLike } from \"@azure/core-util\";\nfunction isNodeReadableStream(x) {\n  return Boolean(x && typeof x[\"pipe\"] === \"function\");\n}\nconst unimplementedMethods = {\n  arrayBuffer: () => {\n    throw new Error(\"Not implemented\");\n  },\n  bytes: () => {\n    throw new Error(\"Not implemented\");\n  },\n  slice: () => {\n    throw new Error(\"Not implemented\");\n  },\n  text: () => {\n    throw new Error(\"Not implemented\");\n  }\n};\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent = Symbol(\"rawContent\");\n/**\n * Type guard to check if a given object is a blob-like object with a raw content property.\n */\nexport function hasRawContent(x) {\n  return typeof x[rawContent] === \"function\";\n}\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the actual blob.\n *\n * @internal\n */\nexport function getRawContent(blob) {\n  if (hasRawContent(blob)) {\n    return blob[rawContent]();\n  } else {\n    return blob;\n  }\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(stream, name, options = {}) {\n  var _a, _b, _c, _d;\n  return Object.assign(Object.assign({}, unimplementedMethods), {\n    type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\",\n    lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(),\n    webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\",\n    size: (_d = options.size) !== null && _d !== void 0 ? _d : -1,\n    name,\n    stream: () => {\n      const s = stream();\n      if (isNodeReadableStream(s)) {\n        throw new Error(\"Not supported: a Node stream was provided as input to createFileFromStream.\");\n      }\n      return s;\n    },\n    [rawContent]: stream\n  });\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(content, name, options = {}) {\n  var _a, _b, _c;\n  if (isNodeLike) {\n    return Object.assign(Object.assign({}, unimplementedMethods), {\n      type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\",\n      lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(),\n      webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\",\n      size: content.byteLength,\n      name,\n      arrayBuffer: async () => content.buffer,\n      stream: () => new Blob([content]).stream(),\n      [rawContent]: () => content\n    });\n  } else {\n    return new File([content], name, options);\n  }\n}","map":{"version":3,"names":["isNodeLike","isNodeReadableStream","x","Boolean","unimplementedMethods","arrayBuffer","Error","bytes","slice","text","rawContent","Symbol","hasRawContent","getRawContent","blob","createFileFromStream","stream","name","options","Object","assign","type","_a","lastModified","_b","Date","getTime","webkitRelativePath","_c","size","_d","s","createFile","content","byteLength","buffer","Blob","File"],"sources":["/Users/user/workspace/eventhorizon/node_modules/@azure/core-rest-pipeline/src/util/file.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isNodeLike } from \"@azure/core-util\";\n\nfunction isNodeReadableStream(x: unknown): x is NodeJS.ReadableStream {\n  return Boolean(x && typeof (x as NodeJS.ReadableStream)[\"pipe\"] === \"function\");\n}\n\n/**\n * Options passed into createFile specifying metadata about the file.\n */\nexport interface CreateFileOptions {\n  /**\n   * The MIME type of the file.\n   */\n  type?: string;\n\n  /**\n   * Last modified time of the file as a UNIX timestamp.\n   * This will default to the current date.\n   */\n  lastModified?: number;\n\n  /**\n   * relative path of this file when uploading a directory.\n   */\n  webkitRelativePath?: string;\n}\n\n/**\n * Extra options for createFile when a stream is being passed in.\n */\nexport interface CreateFileFromStreamOptions extends CreateFileOptions {\n  /**\n   * Size of the file represented by the stream in bytes.\n   *\n   * This will be used by the pipeline when calculating the Content-Length header\n   * for the overall request.\n   */\n  size?: number;\n}\n\nconst unimplementedMethods = {\n  arrayBuffer: () => {\n    throw new Error(\"Not implemented\");\n  },\n  bytes: () => {\n    throw new Error(\"Not implemented\");\n  },\n  slice: () => {\n    throw new Error(\"Not implemented\");\n  },\n  text: () => {\n    throw new Error(\"Not implemented\");\n  },\n};\n\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent: unique symbol = Symbol(\"rawContent\");\n\n/**\n * Type signature of a blob-like object with a raw content property.\n */\nexport interface RawContent extends Blob {\n  [rawContent](): Uint8Array | NodeJS.ReadableStream | ReadableStream<Uint8Array>;\n}\n\n/**\n * Type guard to check if a given object is a blob-like object with a raw content property.\n */\nexport function hasRawContent(x: unknown): x is RawContent {\n  return typeof (x as RawContent)[rawContent] === \"function\";\n}\n\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the actual blob.\n *\n * @internal\n */\nexport function getRawContent(\n  blob: Blob,\n): Blob | NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array {\n  if (hasRawContent(blob)) {\n    return blob[rawContent]();\n  } else {\n    return blob;\n  }\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(\n  stream: () => ReadableStream<Uint8Array> | NodeJS.ReadableStream,\n  name: string,\n  options: CreateFileFromStreamOptions = {},\n): File {\n  return {\n    ...unimplementedMethods,\n    type: options.type ?? \"\",\n    lastModified: options.lastModified ?? new Date().getTime(),\n    webkitRelativePath: options.webkitRelativePath ?? \"\",\n    size: options.size ?? -1,\n    name,\n    stream: () => {\n      const s = stream();\n      if (isNodeReadableStream(s)) {\n        throw new Error(\n          \"Not supported: a Node stream was provided as input to createFileFromStream.\",\n        );\n      }\n\n      return s;\n    },\n    [rawContent]: stream,\n  } as File & RawContent;\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(\n  content: Uint8Array,\n  name: string,\n  options: CreateFileOptions = {},\n): File {\n  if (isNodeLike) {\n    return {\n      ...unimplementedMethods,\n      type: options.type ?? \"\",\n      lastModified: options.lastModified ?? new Date().getTime(),\n      webkitRelativePath: options.webkitRelativePath ?? \"\",\n      size: content.byteLength,\n      name,\n      arrayBuffer: async () => content.buffer,\n      stream: () => new Blob([content]).stream(),\n      [rawContent]: () => content,\n    } as File & RawContent;\n  } else {\n    return new File([content], name, options);\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA,SAASA,UAAU,QAAQ,kBAAkB;AAE7C,SAASC,oBAAoBA,CAACC,CAAU;EACtC,OAAOC,OAAO,CAACD,CAAC,IAAI,OAAQA,CAA2B,CAAC,MAAM,CAAC,KAAK,UAAU,CAAC;AACjF;AAoCA,MAAME,oBAAoB,GAAG;EAC3BC,WAAW,EAAEA,CAAA,KAAK;IAChB,MAAM,IAAIC,KAAK,CAAC,iBAAiB,CAAC;EACpC,CAAC;EACDC,KAAK,EAAEA,CAAA,KAAK;IACV,MAAM,IAAID,KAAK,CAAC,iBAAiB,CAAC;EACpC,CAAC;EACDE,KAAK,EAAEA,CAAA,KAAK;IACV,MAAM,IAAIF,KAAK,CAAC,iBAAiB,CAAC;EACpC,CAAC;EACDG,IAAI,EAAEA,CAAA,KAAK;IACT,MAAM,IAAIH,KAAK,CAAC,iBAAiB,CAAC;EACpC;CACD;AAED;;;;;;;;;;;;;;AAcA,MAAMI,UAAU,GAAkBC,MAAM,CAAC,YAAY,CAAC;AAStD;;;AAGA,OAAM,SAAUC,aAAaA,CAACV,CAAU;EACtC,OAAO,OAAQA,CAAgB,CAACQ,UAAU,CAAC,KAAK,UAAU;AAC5D;AAEA;;;;;;;AAOA,OAAM,SAAUG,aAAaA,CAC3BC,IAAU;EAEV,IAAIF,aAAa,CAACE,IAAI,CAAC,EAAE;IACvB,OAAOA,IAAI,CAACJ,UAAU,CAAC,EAAE;EAC3B,CAAC,MAAM;IACL,OAAOI,IAAI;EACb;AACF;AAEA;;;;;;;;;;;;;;;;;AAiBA,OAAM,SAAUC,oBAAoBA,CAClCC,MAAgE,EAChEC,IAAY,EACZC,OAAA,GAAuC,EAAE;;EAEzC,OAAOC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACFhB,oBAAoB;IACvBiB,IAAI,EAAE,CAAAC,EAAA,GAAAJ,OAAO,CAACG,IAAI,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;IACxBC,YAAY,EAAE,CAAAC,EAAA,GAAAN,OAAO,CAACK,YAAY,cAAAC,EAAA,cAAAA,EAAA,GAAI,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE;IAC1DC,kBAAkB,EAAE,CAAAC,EAAA,GAAAV,OAAO,CAACS,kBAAkB,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;IACpDC,IAAI,EAAE,CAAAC,EAAA,GAAAZ,OAAO,CAACW,IAAI,cAAAC,EAAA,cAAAA,EAAA,GAAI,CAAC,CAAC;IACxBb,IAAI;IACJD,MAAM,EAAEA,CAAA,KAAK;MACX,MAAMe,CAAC,GAAGf,MAAM,EAAE;MAClB,IAAIf,oBAAoB,CAAC8B,CAAC,CAAC,EAAE;QAC3B,MAAM,IAAIzB,KAAK,CACb,6EAA6E,CAC9E;MACH;MAEA,OAAOyB,CAAC;IACV,CAAC;IACD,CAACrB,UAAU,GAAGM;EAAM,EACA;AACxB;AAEA;;;;;;;;;;;AAWA,OAAM,SAAUgB,UAAUA,CACxBC,OAAmB,EACnBhB,IAAY,EACZC,OAAA,GAA6B,EAAE;;EAE/B,IAAIlB,UAAU,EAAE;IACd,OAAOmB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACFhB,oBAAoB;MACvBiB,IAAI,EAAE,CAAAC,EAAA,GAAAJ,OAAO,CAACG,IAAI,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;MACxBC,YAAY,EAAE,CAAAC,EAAA,GAAAN,OAAO,CAACK,YAAY,cAAAC,EAAA,cAAAA,EAAA,GAAI,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE;MAC1DC,kBAAkB,EAAE,CAAAC,EAAA,GAAAV,OAAO,CAACS,kBAAkB,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;MACpDC,IAAI,EAAEI,OAAO,CAACC,UAAU;MACxBjB,IAAI;MACJZ,WAAW,EAAE,MAAAA,CAAA,KAAY4B,OAAO,CAACE,MAAM;MACvCnB,MAAM,EAAEA,CAAA,KAAM,IAAIoB,IAAI,CAAC,CAACH,OAAO,CAAC,CAAC,CAACjB,MAAM,EAAE;MAC1C,CAACN,UAAU,GAAG,MAAMuB;IAAO,EACP;EACxB,CAAC,MAAM;IACL,OAAO,IAAII,IAAI,CAAC,CAACJ,OAAO,CAAC,EAAEhB,IAAI,EAAEC,OAAO,CAAC;EAC3C;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}