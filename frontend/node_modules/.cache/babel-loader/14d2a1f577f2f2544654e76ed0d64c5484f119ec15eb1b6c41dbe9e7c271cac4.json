{"ast":null,"code":"/*! @azure/msal-browser v4.15.0 2025-07-08 */\n'use strict';\n\nimport { invoke, PerformanceEvents, invokeAsync, Constants } from '@azure/msal-common/browser';\nimport { generateHKDF, createNewGuid, generateBaseKey, encrypt, decrypt } from '../crypto/BrowserCrypto.mjs';\nimport { base64DecToArr } from '../encode/Base64Decode.mjs';\nimport { urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { createBrowserConfigurationAuthError } from '../error/BrowserConfigurationAuthError.mjs';\nimport { CookieStorage, SameSiteOptions } from './CookieStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { getAccountKeys, getTokenKeys } from './CacheHelpers.mjs';\nimport { StaticCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { storageNotSupported } from '../error/BrowserConfigurationAuthErrorCodes.mjs';\nimport { uninitializedPublicClientApplication } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst ENCRYPTION_KEY = \"msal.cache.encryption\";\nconst BROADCAST_CHANNEL_NAME = \"msal.broadcast.cache\";\nclass LocalStorage {\n  constructor(clientId, logger, performanceClient) {\n    if (!window.localStorage) {\n      throw createBrowserConfigurationAuthError(storageNotSupported);\n    }\n    this.memoryStorage = new MemoryStorage();\n    this.initialized = false;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n  }\n  async initialize(correlationId) {\n    const cookies = new CookieStorage();\n    const cookieString = cookies.getItem(ENCRYPTION_KEY);\n    let parsedCookie = {\n      key: \"\",\n      id: \"\"\n    };\n    if (cookieString) {\n      try {\n        parsedCookie = JSON.parse(cookieString);\n      } catch (e) {}\n    }\n    if (parsedCookie.key && parsedCookie.id) {\n      // Encryption key already exists, import\n      const baseKey = invoke(base64DecToArr, PerformanceEvents.Base64Decode, this.logger, this.performanceClient, correlationId)(parsedCookie.key);\n      this.encryptionCookie = {\n        id: parsedCookie.id,\n        key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)\n      };\n      await invokeAsync(this.importExistingCache.bind(this), PerformanceEvents.ImportExistingCache, this.logger, this.performanceClient, correlationId)(correlationId);\n    } else {\n      // Encryption key doesn't exist or is invalid, generate a new one and clear existing cache\n      this.clear();\n      const id = createNewGuid();\n      const baseKey = await invokeAsync(generateBaseKey, PerformanceEvents.GenerateBaseKey, this.logger, this.performanceClient, correlationId)();\n      const keyStr = invoke(urlEncodeArr, PerformanceEvents.UrlEncodeArr, this.logger, this.performanceClient, correlationId)(new Uint8Array(baseKey));\n      this.encryptionCookie = {\n        id: id,\n        key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)\n      };\n      const cookieData = {\n        id: id,\n        key: keyStr\n      };\n      cookies.setItem(ENCRYPTION_KEY, JSON.stringify(cookieData), 0,\n      // Expiration - 0 means cookie will be cleared at the end of the browser session\n      true,\n      // Secure flag\n      SameSiteOptions.None // SameSite must be None to support iframed apps\n      );\n    }\n    // Register listener for cache updates in other tabs\n    this.broadcast.addEventListener(\"message\", this.updateCache.bind(this));\n    this.initialized = true;\n  }\n  getItem(key) {\n    return window.localStorage.getItem(key);\n  }\n  getUserData(key) {\n    if (!this.initialized) {\n      throw createBrowserAuthError(uninitializedPublicClientApplication);\n    }\n    return this.memoryStorage.getItem(key);\n  }\n  setItem(key, value) {\n    window.localStorage.setItem(key, value);\n  }\n  async setUserData(key, value, correlationId, timestamp) {\n    if (!this.initialized || !this.encryptionCookie) {\n      throw createBrowserAuthError(uninitializedPublicClientApplication);\n    }\n    const {\n      data,\n      nonce\n    } = await invokeAsync(encrypt, PerformanceEvents.Encrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, value, this.getContext(key));\n    const encryptedData = {\n      id: this.encryptionCookie.id,\n      nonce: nonce,\n      data: data,\n      lastUpdatedAt: timestamp\n    };\n    this.memoryStorage.setItem(key, value);\n    this.setItem(key, JSON.stringify(encryptedData));\n    // Notify other frames to update their in-memory cache\n    this.broadcast.postMessage({\n      key: key,\n      value: value,\n      context: this.getContext(key)\n    });\n  }\n  removeItem(key) {\n    if (this.memoryStorage.containsKey(key)) {\n      this.memoryStorage.removeItem(key);\n      this.broadcast.postMessage({\n        key: key,\n        value: null,\n        context: this.getContext(key)\n      });\n    }\n    window.localStorage.removeItem(key);\n  }\n  getKeys() {\n    return Object.keys(window.localStorage);\n  }\n  containsKey(key) {\n    return window.localStorage.hasOwnProperty(key);\n  }\n  /**\r\n   * Removes all known MSAL keys from the cache\r\n   */\n  clear() {\n    // Removes all remaining MSAL cache items\n    this.memoryStorage.clear();\n    const accountKeys = getAccountKeys(this);\n    accountKeys.forEach(key => this.removeItem(key));\n    const tokenKeys = getTokenKeys(this.clientId, this);\n    tokenKeys.idToken.forEach(key => this.removeItem(key));\n    tokenKeys.accessToken.forEach(key => this.removeItem(key));\n    tokenKeys.refreshToken.forEach(key => this.removeItem(key));\n    // Clean up anything left\n    this.getKeys().forEach(cacheKey => {\n      if (cacheKey.startsWith(Constants.CACHE_PREFIX) || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeItem(cacheKey);\n      }\n    });\n  }\n  /**\r\n   * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage\r\n   * @returns\r\n   */\n  async importExistingCache(correlationId) {\n    if (!this.encryptionCookie) {\n      return;\n    }\n    let accountKeys = getAccountKeys(this);\n    accountKeys = await this.importArray(accountKeys, correlationId);\n    // Write valid account keys back to map\n    this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n    const tokenKeys = getTokenKeys(this.clientId, this);\n    tokenKeys.idToken = await this.importArray(tokenKeys.idToken, correlationId);\n    tokenKeys.accessToken = await this.importArray(tokenKeys.accessToken, correlationId);\n    tokenKeys.refreshToken = await this.importArray(tokenKeys.refreshToken, correlationId);\n    // Write valid token keys back to map\n    this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\r\n   * Helper to decrypt and save cache entries\r\n   * @param key\r\n   * @returns\r\n   */\n  async getItemFromEncryptedCache(key, correlationId) {\n    if (!this.encryptionCookie) {\n      return null;\n    }\n    const rawCache = this.getItem(key);\n    if (!rawCache) {\n      return null;\n    }\n    let encObj;\n    try {\n      encObj = JSON.parse(rawCache);\n    } catch (e) {\n      // Not a valid encrypted object, remove\n      return null;\n    }\n    if (!encObj.id || !encObj.nonce || !encObj.data) {\n      // Data is not encrypted, likely from old version of MSAL. It must be removed because we don't know how old it is.\n      this.performanceClient.incrementFields({\n        unencryptedCacheCount: 1\n      }, correlationId);\n      return null;\n    }\n    if (encObj.id !== this.encryptionCookie.id) {\n      // Data was encrypted with a different key. It must be removed because it is from a previous session.\n      this.performanceClient.incrementFields({\n        encryptedCacheExpiredCount: 1\n      }, correlationId);\n      return null;\n    }\n    return invokeAsync(decrypt, PerformanceEvents.Decrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, encObj.nonce, this.getContext(key), encObj.data);\n  }\n  /**\r\n   * Helper to decrypt and save an array of cache keys\r\n   * @param arr\r\n   * @returns Array of keys successfully imported\r\n   */\n  async importArray(arr, correlationId) {\n    const importedArr = [];\n    const promiseArr = [];\n    arr.forEach(key => {\n      const promise = this.getItemFromEncryptedCache(key, correlationId).then(value => {\n        if (value) {\n          this.memoryStorage.setItem(key, value);\n          importedArr.push(key);\n        } else {\n          // If value is empty, unencrypted or expired remove\n          this.removeItem(key);\n        }\n      });\n      promiseArr.push(promise);\n    });\n    await Promise.all(promiseArr);\n    return importedArr;\n  }\n  /**\r\n   * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries\r\n   * @param key\r\n   * @returns\r\n   */\n  getContext(key) {\n    let context = \"\";\n    if (key.includes(this.clientId)) {\n      context = this.clientId; // Used to bind encryption key to this appId\n    }\n    return context;\n  }\n  updateCache(event) {\n    this.logger.trace(\"Updating internal cache from broadcast event\");\n    const perfMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.LocalStorageUpdated);\n    perfMeasurement.add({\n      isBackground: true\n    });\n    const {\n      key,\n      value,\n      context\n    } = event.data;\n    if (!key) {\n      this.logger.error(\"Broadcast event missing key\");\n      perfMeasurement.end({\n        success: false,\n        errorCode: \"noKey\"\n      });\n      return;\n    }\n    if (context && context !== this.clientId) {\n      this.logger.trace(`Ignoring broadcast event from clientId: ${context}`);\n      perfMeasurement.end({\n        success: false,\n        errorCode: \"contextMismatch\"\n      });\n      return;\n    }\n    if (!value) {\n      this.memoryStorage.removeItem(key);\n      this.logger.verbose(\"Removed item from internal cache\");\n    } else {\n      this.memoryStorage.setItem(key, value);\n      this.logger.verbose(\"Updated item in internal cache\");\n    }\n    perfMeasurement.end({\n      success: true\n    });\n  }\n}\nexport { LocalStorage };","map":{"version":3,"names":["ENCRYPTION_KEY","BROADCAST_CHANNEL_NAME","LocalStorage","constructor","clientId","logger","performanceClient","window","localStorage","createBrowserConfigurationAuthError","storageNotSupported","memoryStorage","MemoryStorage","initialized","broadcast","BroadcastChannel","initialize","correlationId","cookies","CookieStorage","cookieString","getItem","parsedCookie","key","id","JSON","parse","e","baseKey","invoke","base64DecToArr","PerformanceEvents","Base64Decode","encryptionCookie","invokeAsync","generateHKDF","GenerateHKDF","importExistingCache","bind","ImportExistingCache","clear","createNewGuid","generateBaseKey","GenerateBaseKey","keyStr","urlEncodeArr","UrlEncodeArr","Uint8Array","cookieData","setItem","stringify","SameSiteOptions","None","addEventListener","updateCache","getUserData","createBrowserAuthError","uninitializedPublicClientApplication","value","setUserData","timestamp","data","nonce","encrypt","Encrypt","getContext","encryptedData","lastUpdatedAt","postMessage","context","removeItem","containsKey","getKeys","Object","keys","hasOwnProperty","accountKeys","getAccountKeys","forEach","tokenKeys","getTokenKeys","idToken","accessToken","refreshToken","cacheKey","startsWith","Constants","CACHE_PREFIX","indexOf","importArray","StaticCacheKeys","ACCOUNT_KEYS","TOKEN_KEYS","getItemFromEncryptedCache","rawCache","encObj","incrementFields","unencryptedCacheCount","encryptedCacheExpiredCount","decrypt","Decrypt","arr","importedArr","promiseArr","promise","then","push","Promise","all","includes","event","trace","perfMeasurement","startMeasurement","LocalStorageUpdated","add","isBackground","error","end","success","errorCode","verbose"],"sources":["/Users/user/workspace/eventhorizon/node_modules/@azure/msal-browser/src/cache/LocalStorage.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Constants,\n    TokenKeys,\n    IPerformanceClient,\n    invokeAsync,\n    PerformanceEvents,\n    Logger,\n    invoke,\n} from \"@azure/msal-common/browser\";\nimport {\n    createNewGuid,\n    decrypt,\n    encrypt,\n    generateBaseKey,\n    generateHKDF,\n} from \"../crypto/BrowserCrypto.js\";\nimport { base64DecToArr } from \"../encode/Base64Decode.js\";\nimport { urlEncodeArr } from \"../encode/Base64Encode.js\";\nimport {\n    BrowserAuthErrorCodes,\n    createBrowserAuthError,\n} from \"../error/BrowserAuthError.js\";\nimport {\n    BrowserConfigurationAuthErrorCodes,\n    createBrowserConfigurationAuthError,\n} from \"../error/BrowserConfigurationAuthError.js\";\nimport { CookieStorage, SameSiteOptions } from \"./CookieStorage.js\";\nimport { IWindowStorage } from \"./IWindowStorage.js\";\nimport { MemoryStorage } from \"./MemoryStorage.js\";\nimport { getAccountKeys, getTokenKeys } from \"./CacheHelpers.js\";\nimport { StaticCacheKeys } from \"../utils/BrowserConstants.js\";\n\nconst ENCRYPTION_KEY = \"msal.cache.encryption\";\nconst BROADCAST_CHANNEL_NAME = \"msal.broadcast.cache\";\n\ntype EncryptionCookie = {\n    id: string;\n    key: CryptoKey;\n};\n\ntype EncryptedData = {\n    id: string;\n    nonce: string;\n    data: string;\n    lastUpdatedAt: string;\n};\n\nexport class LocalStorage implements IWindowStorage<string> {\n    private clientId: string;\n    private initialized: boolean;\n    private memoryStorage: MemoryStorage<string>;\n    private performanceClient: IPerformanceClient;\n    private logger: Logger;\n    private encryptionCookie?: EncryptionCookie;\n    private broadcast: BroadcastChannel;\n\n    constructor(\n        clientId: string,\n        logger: Logger,\n        performanceClient: IPerformanceClient\n    ) {\n        if (!window.localStorage) {\n            throw createBrowserConfigurationAuthError(\n                BrowserConfigurationAuthErrorCodes.storageNotSupported\n            );\n        }\n        this.memoryStorage = new MemoryStorage<string>();\n        this.initialized = false;\n        this.clientId = clientId;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n        this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n    }\n\n    async initialize(correlationId: string): Promise<void> {\n        const cookies = new CookieStorage();\n        const cookieString = cookies.getItem(ENCRYPTION_KEY);\n        let parsedCookie = { key: \"\", id: \"\" };\n        if (cookieString) {\n            try {\n                parsedCookie = JSON.parse(cookieString);\n            } catch (e) {}\n        }\n        if (parsedCookie.key && parsedCookie.id) {\n            // Encryption key already exists, import\n            const baseKey = invoke(\n                base64DecToArr,\n                PerformanceEvents.Base64Decode,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )(parsedCookie.key);\n            this.encryptionCookie = {\n                id: parsedCookie.id,\n                key: await invokeAsync(\n                    generateHKDF,\n                    PerformanceEvents.GenerateHKDF,\n                    this.logger,\n                    this.performanceClient,\n                    correlationId\n                )(baseKey),\n            };\n            await invokeAsync(\n                this.importExistingCache.bind(this),\n                PerformanceEvents.ImportExistingCache,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )(correlationId);\n        } else {\n            // Encryption key doesn't exist or is invalid, generate a new one and clear existing cache\n            this.clear();\n            const id = createNewGuid();\n            const baseKey = await invokeAsync(\n                generateBaseKey,\n                PerformanceEvents.GenerateBaseKey,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )();\n            const keyStr = invoke(\n                urlEncodeArr,\n                PerformanceEvents.UrlEncodeArr,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )(new Uint8Array(baseKey));\n            this.encryptionCookie = {\n                id: id,\n                key: await invokeAsync(\n                    generateHKDF,\n                    PerformanceEvents.GenerateHKDF,\n                    this.logger,\n                    this.performanceClient,\n                    correlationId\n                )(baseKey),\n            };\n\n            const cookieData = {\n                id: id,\n                key: keyStr,\n            };\n\n            cookies.setItem(\n                ENCRYPTION_KEY,\n                JSON.stringify(cookieData),\n                0, // Expiration - 0 means cookie will be cleared at the end of the browser session\n                true, // Secure flag\n                SameSiteOptions.None // SameSite must be None to support iframed apps\n            );\n        }\n\n        // Register listener for cache updates in other tabs\n        this.broadcast.addEventListener(\"message\", this.updateCache.bind(this));\n\n        this.initialized = true;\n    }\n\n    getItem(key: string): string | null {\n        return window.localStorage.getItem(key);\n    }\n\n    getUserData(key: string): string | null {\n        if (!this.initialized) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.uninitializedPublicClientApplication\n            );\n        }\n        return this.memoryStorage.getItem(key);\n    }\n\n    setItem(key: string, value: string): void {\n        window.localStorage.setItem(key, value);\n    }\n\n    async setUserData(\n        key: string,\n        value: string,\n        correlationId: string,\n        timestamp: string\n    ): Promise<void> {\n        if (!this.initialized || !this.encryptionCookie) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.uninitializedPublicClientApplication\n            );\n        }\n\n        const { data, nonce } = await invokeAsync(\n            encrypt,\n            PerformanceEvents.Encrypt,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )(this.encryptionCookie.key, value, this.getContext(key));\n        const encryptedData: EncryptedData = {\n            id: this.encryptionCookie.id,\n            nonce: nonce,\n            data: data,\n            lastUpdatedAt: timestamp,\n        };\n\n        this.memoryStorage.setItem(key, value);\n        this.setItem(key, JSON.stringify(encryptedData));\n\n        // Notify other frames to update their in-memory cache\n        this.broadcast.postMessage({\n            key: key,\n            value: value,\n            context: this.getContext(key),\n        });\n    }\n\n    removeItem(key: string): void {\n        if (this.memoryStorage.containsKey(key)) {\n            this.memoryStorage.removeItem(key);\n            this.broadcast.postMessage({\n                key: key,\n                value: null,\n                context: this.getContext(key),\n            });\n        }\n        window.localStorage.removeItem(key);\n    }\n\n    getKeys(): string[] {\n        return Object.keys(window.localStorage);\n    }\n\n    containsKey(key: string): boolean {\n        return window.localStorage.hasOwnProperty(key);\n    }\n\n    /**\n     * Removes all known MSAL keys from the cache\n     */\n    clear(): void {\n        // Removes all remaining MSAL cache items\n        this.memoryStorage.clear();\n\n        const accountKeys = getAccountKeys(this);\n        accountKeys.forEach((key) => this.removeItem(key));\n        const tokenKeys = getTokenKeys(this.clientId, this);\n        tokenKeys.idToken.forEach((key) => this.removeItem(key));\n        tokenKeys.accessToken.forEach((key) => this.removeItem(key));\n        tokenKeys.refreshToken.forEach((key) => this.removeItem(key));\n\n        // Clean up anything left\n        this.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.startsWith(Constants.CACHE_PREFIX) ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.removeItem(cacheKey);\n            }\n        });\n    }\n\n    /**\n     * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage\n     * @returns\n     */\n    private async importExistingCache(correlationId: string): Promise<void> {\n        if (!this.encryptionCookie) {\n            return;\n        }\n\n        let accountKeys = getAccountKeys(this);\n        accountKeys = await this.importArray(accountKeys, correlationId);\n        // Write valid account keys back to map\n        this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n\n        const tokenKeys: TokenKeys = getTokenKeys(this.clientId, this);\n        tokenKeys.idToken = await this.importArray(\n            tokenKeys.idToken,\n            correlationId\n        );\n        tokenKeys.accessToken = await this.importArray(\n            tokenKeys.accessToken,\n            correlationId\n        );\n        tokenKeys.refreshToken = await this.importArray(\n            tokenKeys.refreshToken,\n            correlationId\n        );\n        // Write valid token keys back to map\n        this.setItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\n            JSON.stringify(tokenKeys)\n        );\n    }\n\n    /**\n     * Helper to decrypt and save cache entries\n     * @param key\n     * @returns\n     */\n    private async getItemFromEncryptedCache(\n        key: string,\n        correlationId: string\n    ): Promise<string | null> {\n        if (!this.encryptionCookie) {\n            return null;\n        }\n\n        const rawCache = this.getItem(key);\n        if (!rawCache) {\n            return null;\n        }\n\n        let encObj: EncryptedData;\n        try {\n            encObj = JSON.parse(rawCache);\n        } catch (e) {\n            // Not a valid encrypted object, remove\n            return null;\n        }\n\n        if (!encObj.id || !encObj.nonce || !encObj.data) {\n            // Data is not encrypted, likely from old version of MSAL. It must be removed because we don't know how old it is.\n            this.performanceClient.incrementFields(\n                { unencryptedCacheCount: 1 },\n                correlationId\n            );\n            return null;\n        }\n\n        if (encObj.id !== this.encryptionCookie.id) {\n            // Data was encrypted with a different key. It must be removed because it is from a previous session.\n            this.performanceClient.incrementFields(\n                { encryptedCacheExpiredCount: 1 },\n                correlationId\n            );\n            return null;\n        }\n\n        return invokeAsync(\n            decrypt,\n            PerformanceEvents.Decrypt,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )(\n            this.encryptionCookie.key,\n            encObj.nonce,\n            this.getContext(key),\n            encObj.data\n        );\n    }\n\n    /**\n     * Helper to decrypt and save an array of cache keys\n     * @param arr\n     * @returns Array of keys successfully imported\n     */\n    private async importArray(\n        arr: Array<string>,\n        correlationId: string\n    ): Promise<Array<string>> {\n        const importedArr: Array<string> = [];\n        const promiseArr: Array<Promise<void>> = [];\n        arr.forEach((key) => {\n            const promise = this.getItemFromEncryptedCache(\n                key,\n                correlationId\n            ).then((value) => {\n                if (value) {\n                    this.memoryStorage.setItem(key, value);\n                    importedArr.push(key);\n                } else {\n                    // If value is empty, unencrypted or expired remove\n                    this.removeItem(key);\n                }\n            });\n            promiseArr.push(promise);\n        });\n\n        await Promise.all(promiseArr);\n        return importedArr;\n    }\n\n    /**\n     * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries\n     * @param key\n     * @returns\n     */\n    private getContext(key: string): string {\n        let context = \"\";\n        if (key.includes(this.clientId)) {\n            context = this.clientId; // Used to bind encryption key to this appId\n        }\n\n        return context;\n    }\n\n    private updateCache(event: MessageEvent): void {\n        this.logger.trace(\"Updating internal cache from broadcast event\");\n        const perfMeasurement = this.performanceClient.startMeasurement(\n            PerformanceEvents.LocalStorageUpdated\n        );\n        perfMeasurement.add({ isBackground: true });\n\n        const { key, value, context } = event.data;\n        if (!key) {\n            this.logger.error(\"Broadcast event missing key\");\n            perfMeasurement.end({ success: false, errorCode: \"noKey\" });\n            return;\n        }\n\n        if (context && context !== this.clientId) {\n            this.logger.trace(\n                `Ignoring broadcast event from clientId: ${context}`\n            );\n            perfMeasurement.end({\n                success: false,\n                errorCode: \"contextMismatch\",\n            });\n            return;\n        }\n\n        if (!value) {\n            this.memoryStorage.removeItem(key);\n            this.logger.verbose(\"Removed item from internal cache\");\n        } else {\n            this.memoryStorage.setItem(key, value);\n            this.logger.verbose(\"Updated item in internal cache\");\n        }\n        perfMeasurement.end({ success: true });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}